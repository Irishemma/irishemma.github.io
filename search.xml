<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用ceph-deploy工具部署ceph集群</title>
    <url>/2019/04/20/Ceph/%E4%BD%BF%E7%94%A8ceph-deploy%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2ceph%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<blockquote>
<p>系统centos7.2<br>ceph版本 ceph version 10.2.2<br>测试服务器为kvm虚拟机</p>
</blockquote>
<ul>
<li>硬件</li>
<li>环境预检</li>
<li>安装ceph-deploy工具</li>
<li>安装ceph集群<ul>
<li>ceph软件包安装</li>
<li>创建ceph集群</li>
<li>配置文件</li>
<li>添加mons</li>
<li>key管理</li>
</ul>
</li>
<li>osd创建<ul>
<li>准备osd</li>
<li>激活osd</li>
</ul>
</li>
<li>ceph-deploy使用</li>
<li>关于udev</li>
</ul>
<a id="more"></a>
<p><a href="https://opengers.github.io/ceph/deploy-a-ceph-cluster-manually/" target="_blank" rel="noopener">手工部署ceph集群</a><br><a href="https://opengers.github.io/ceph/deploy-a-ceph-cluster-use-ceph-deploy/" target="_blank" rel="noopener">ceph-deploy部署ceph集群</a></p>
<p>ceph的部署过程在官网有<a href="http://docs.ceph.com/docs/master/start/quick-ceph-deploy/" target="_blank" rel="noopener">详细记录</a>，<a href="http://docs.ceph.org.cn/start/quick-start-preflight/" target="_blank" rel="noopener">ceph中国社区</a>也有翻译的中文文档</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>ceph为廉价普通硬件而设计，在其上可以构建PB级的数据集群，其数据高可靠性主要依靠软件层良好的算法来保障。因为是廉价硬件，因此在一个大型集群中，硬件故障会很频繁发生，对于一个设计良好的ceph集群，这并不会对集群造成数据丢失</p>
<p>本篇文章是记录下自己的部署过程，服务器使用kvm虚拟机，只测试功能，服务器分配如下</p>
<hr>
<table>
<thead>
<tr>
<th>节点</th>
<th>服务</th>
<th>cluster network</th>
<th>public network</th>
</tr>
</thead>
<tbody>
<tr>
<td>node1(admin-node)</td>
<td>osd.{1,2,3,4},mon.node1</td>
<td>eth1:172.31.6.174/24</td>
<td>eth0:192.168.6.174/22</td>
</tr>
<tr>
<td>node2</td>
<td>osd.{5,6,7,8},mon.node2</td>
<td>eth1:172.31.6.175/24</td>
<td>eth0:192.168.6.175/22</td>
</tr>
<tr>
<td>node3</td>
<td>osd.{9,10,11,12},mon.node3</td>
<td>eth1:172.31.6.176/24</td>
<td>eth0:192.168.6.176/22</td>
</tr>
</tbody>
</table>
<hr>
<p>每个节点都有五块磁盘，前4块磁盘部署4个<code>osd</code>，第5块磁盘建立四个相等大小分区作为四个osd盘的日志分区。这样，集群共有12个<code>osd</code>进程，3个<code>monitor</code>进程。管理节点用作执行<code>ceph-deploy</code>命令，可以使用node1节点充当</p>
<p>cluster network 是处理osd间的数据复制，数据重平衡，osd进程心跳检测的网络，其不对外提供服务，只在各个osd节点间通信，本文使用eth1网卡作为cluster network，三个节点网卡eth1桥接到同一个网桥br1上</p>
<h2 id="环境预检"><a href="#环境预检" class="headerlink" title="环境预检"></a>环境预检</h2><p>部署集群之前，需要进行环境准备，这些步骤应当设置于集群所有节点</p>
<p><strong>ntp同步</strong></p>
<p>各osd节点间需要设置时间同步，节点时钟偏差过大会引起pg异常</p>
<p><strong>hostname设置</strong></p>
<p>Cluster Map中会使用主机hostname作为名称表示，因此hostname需要好好规划</p>
<p><strong>hosts添加</strong></p>
<p>每个节点都添加集群所有节点的hosts，<code>ceph.conf</code>配置文件中会使用到，如下是<code>node1</code>节点的hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">#::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">172.31.6.174 node1</span><br><span class="line">172.31.6.175 node2</span><br><span class="line">172.31.6.176 node3</span><br></pre></td></tr></table></figure>
<p><strong>配置ceph源</strong></p>
<p>不要指望使用<a href="http://download.ceph.com/rpm-jewel/el7/" target="_blank" rel="noopener">ceph官方源</a>，这里需要使用国内第三方源，比如163的ceph源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ceph]</span><br><span class="line">name=Ceph packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-jewel/el7/x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">priority=2</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-jewel/el7/noarch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">priority=2</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-source]</span><br><span class="line">name=Ceph source packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/</span><br><span class="line">enabled=0</span><br><span class="line">gpgcheck=1</span><br><span class="line">priority=2</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</span><br></pre></td></tr></table></figure>
<p>注意这里<code>priority</code>可以设置yum源的优先级，如果你其它源中也有ceph软件包，需要保证这里的<code>ceph.repo</code>的优先级<code>priority</code>比其它的高(值越小越高)，为此需要安装下面这个软件包，用以支持yum源的优先级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install yum-plugin-priorities</span><br></pre></td></tr></table></figure>
<p>下面这些依赖包也需要在每个节点都安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils snappy leveldb gdiskpython-argparse gperftools-libs ntpdate</span><br></pre></td></tr></table></figure>
<p><strong>内核调整</strong></p>
<p><code>osd</code>进程可以产生大量线程，如有需要，可以调整下内核最大允许线程数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel.pid_max = 4194303</span><br></pre></td></tr></table></figure>
<h2 id="安装ceph-deploy工具"><a href="#安装ceph-deploy工具" class="headerlink" title="安装ceph-deploy工具"></a>安装ceph-deploy工具</h2><p><code>ceph-deploy</code>是ceph官方提供的部署工具，它通过ssh远程登录其它各个节点上执行命令完成部署过程，我们可以随意选择一台服务器安装此工具，为方便，这里我们选择<code>node1</code>节点安装<code>ceph-deploy</code></p>
<p>我们把<code>node1</code>节点上的<code>/data/ceph/deploy</code>目录作为<code>ceph-deploy</code>部署目录，其部署过程中生成的配置文件，key密钥，日志等都位于此目录下，因此下面部署应当始终在此目录下进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install ceph-deploy</span><br><span class="line"></span><br><span class="line">mkdir -p /data/ceph/deploy</span><br></pre></td></tr></table></figure>
<p><code>ceph-deploy</code>工具默认使用root用户SSH到各Ceph节点执行命令。为了方便，可以配置<code>ceph-deploy</code>免密码登陆各个节点。如果ceph-deploy以某个普通用户登陆，那么这个用户必须有无密码使用sudo的权限。</p>
<h2 id="安装ceph集群"><a href="#安装ceph集群" class="headerlink" title="安装ceph集群"></a>安装ceph集群</h2><h4 id="ceph软件包安装"><a href="#ceph软件包安装" class="headerlink" title="ceph软件包安装"></a>ceph软件包安装</h4><p>首先安装ceph软件包到三个节点上。上面我们已经配置好ceph源，因此这里使用<code>--no-adjust-repos</code>参数忽略设置ceph源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ceph-deploy --username root install --no-adjust-repos node1 node2 node3</span><br><span class="line">ceph-deploy install --no-adjust-repos node1 node2 node3</span><br></pre></td></tr></table></figure>
<h4 id="创建ceph集群"><a href="#创建ceph集群" class="headerlink" title="创建ceph集群"></a>创建ceph集群</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy new --cluster-network 172.31.6.0/24 --public-network 192.168.4.0/22 node1 node2 node3</span><br><span class="line"></span><br><span class="line">#上步会创建一个ceph.conf配置文件和一个监视器密钥环到各个节点的/etc/ceph/目录，ceph.conf中会有`fsid`，`mon_initial_members`，`mon_host`三个参数  </span><br><span class="line"></span><br><span class="line">#默认ceph使用集群名ceph，可以使用下面命令创建一个指定的ceph集群名称</span><br><span class="line">#ceph-deploy --cluster &#123;cluster-name&#125; new &#123;host [host], ...&#125;</span><br></pre></td></tr></table></figure>
<p><code>Ceph Monitors</code>之间默认使用<code>6789</code>端口通信， OSD之间默认用<code>6800:7300</code> 范围内的端口通信，多个集群应当保证端口不冲突</p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>修改<code>ceph-deploy</code>目录<code>/data/ceph/deploy</code>下的<code>ceph.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#/data/ceph/deploy/ceph.conf添加如下参数  </span><br><span class="line">osd_journal_size = 7168</span><br><span class="line">osd_pool_default_size = 2</span><br><span class="line"></span><br><span class="line">osd_pool_default_pg_num = 512</span><br><span class="line">osd_pool_default_pgp_num = 512</span><br><span class="line">rbd_default_features = 3</span><br></pre></td></tr></table></figure>
<h4 id="添加mons"><a href="#添加mons" class="headerlink" title="添加mons"></a>添加mons</h4><p>我们这里创建三个Monitor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy mon create node1 node2 node3</span><br><span class="line"></span><br><span class="line">#上面命令效果如下</span><br><span class="line">#1.write cluster configuration to /etc/ceph/&#123;cluster&#125;.conf</span><br><span class="line">#2.生成/var/lib/ceph/mon/ceph-node1/keyring</span><br><span class="line">#3.systemctl enable ceph-mon@node1</span><br><span class="line">#4.systemctl start ceph-mon@node1</span><br></pre></td></tr></table></figure>
<p>在一主机上新增监视器时，如果它不是由<code>ceph-deploy new</code>命令所定义的，那就必须把<code>public network</code>加入 ceph.conf配置文件</p>
<h4 id="key管理"><a href="#key管理" class="headerlink" title="key管理"></a>key管理</h4><p>为节点准备认证key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy gatherkeys node1 node2 node3</span><br><span class="line"></span><br><span class="line">#若有需要，可以删除管理主机上、本地目录中的密钥。可用下列命令：</span><br><span class="line">#ceph-deploy forgetkeys</span><br></pre></td></tr></table></figure>
<h2 id="osd创建"><a href="#osd创建" class="headerlink" title="osd创建"></a>osd创建</h2><p>创建集群，安装ceph包，收集密钥之后，就可以创建osd了</p>
<h4 id="准备osd"><a href="#准备osd" class="headerlink" title="准备osd"></a>准备osd</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd prepare node1:vdb:/dev/vdf node1:vdc:/dev/vdf node1:vdd:/dev/vdf node1:vde:/dev/vdf node2:vdb:/dev/vdf node2:vdc:/dev/vdf node2:vdd:/dev/vdf node2:vde:/dev/vdf node3:vdb:/dev/vdf node3:vdc:/dev/vdf node3:vdd:/dev/vdf node3:vde:/dev/vdf</span><br><span class="line">#可以prepare多个osd</span><br><span class="line">#node1:vdb:/dev/vdf 意思是在node1上创建一个osd，使用磁盘vdb作为数据盘，osd journal分区从vdf磁盘上划分</span><br></pre></td></tr></table></figure>
<p>每个节点上四个osd磁盘<code>vd{b,c,d,e}</code>，使用同一个日志盘<code>/dev/vdf</code>，<code>prepare</code>过程中ceph会自动在<code>/dev/vdf</code>上创建4个日志分区供4个osd使用，日志分区的大小由上步骤<code>osd_journal_size = 7168</code>(7G)指定，你应当修改这个值<br>prepare 命令只准备 OSD。在大多数操作系统中，硬盘分区创建后，不用 activate 命令也会自动执行 activate 阶段（通过 Ceph 的 udev 规则）</p>
<h4 id="激活osd"><a href="#激活osd" class="headerlink" title="激活osd"></a>激活osd</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy osd activate node1:vdb1:/dev/vdf1 node1:vdc1:/dev/vdf2 node1:vdd1:/dev/vdf3 node1:vde1:/dev/vdf4 node2:vdb1:/dev/vdf1 node2:vdc1:/dev/vdf2 node2:vdd1:/dev/vdf3 node2:vde1:/dev/vdf4 node3:vdb1:/dev/vdf1 node3:vdc1:/dev/vdf2 node3:vdd1:/dev/vdf3 node3:vde1:/dev/vdf4</span><br><span class="line"></span><br><span class="line">#vdf1,vdf2,vdf3,vdf4 为ceph自动创建的四个日志分区</span><br></pre></td></tr></table></figure>
<p>activate 命令会让 OSD 进入 up 且 in 状态，此命令所用路径和 prepare 相同。在一个节点运行多个OSD 守护进程、且多个 OSD 守护进程共享一个日志分区时，你应该考虑整个节点的最小 CRUSH 故障域，因为如果这个 SSD 坏了，所有用其做日志的 OSD 守护进程也会失效</p>
<h2 id="ceph-deploy使用"><a href="#ceph-deploy使用" class="headerlink" title="ceph-deploy使用"></a>ceph-deploy使用</h2><ul>
<li>允许一主机以管理员权限执行 Ceph 命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy admin &#123;host-name [host-name]...&#125;</span><br><span class="line">#拷贝ceph.conf和client.admin.keyring到远程主机上</span><br></pre></td></tr></table></figure>
<ul>
<li>把改过的配置文件分发给集群内各主机</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf config push node&#123;1..3&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ceph-deploy执行后的清除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#卸载指定节点上的ceph软件包  </span><br><span class="line">ceph-deploy uninstall &#123;hostname [hostname] ...&#125;</span><br><span class="line"></span><br><span class="line">#清除数据   </span><br><span class="line">#如果只想清除 /var/lib/ceph下的数据、并保留Ceph安装包</span><br><span class="line">ceph-deploy purgedata &#123;hostname&#125; [&#123;hostname&#125; ...]</span><br><span class="line"></span><br><span class="line">#要清理掉 /var/lib/ceph 下的所有数据、并卸载 Ceph 软件包</span><br><span class="line">ceph-deploy purge &#123;hostname&#125; [&#123;hostname&#125; ...]</span><br></pre></td></tr></table></figure>
<ul>
<li>清除磁盘操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看某节点上所有磁盘</span><br><span class="line">ceph-deploy disk list &#123;node-name [node-name]...&#125;</span><br><span class="line">#清除指定磁盘上的分区，用于重装ceph集群</span><br><span class="line">#ceph-deploy disk zap &#123;osd-server-name&#125;:&#123;disk-name&#125;</span><br><span class="line">ceph-deploy disk zap node1:/dev/vdb</span><br></pre></td></tr></table></figure>
<ul>
<li>monitor操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从某个节点上移除Ceph MON进程</span><br><span class="line">ceph-deploy mon destroy &#123;host-name [host-name]...&#125;</span><br><span class="line">#ceph集群至少需要一个mon进程，但一个mon进程无法保证高可靠性。确保你删除一个监视器后，集群仍能正常工作。</span><br></pre></td></tr></table></figure>
<h2 id="关于udev"><a href="#关于udev" class="headerlink" title="关于udev"></a>关于udev</h2><p>可以看到，<code>ceph-deploy</code>部署过程中并没有把osd数据盘的挂载信息写入<code>/etc/fstab</code>，但是重启节点后，osd数据盘也会自动挂载，这是因为其利用了linux内核提供的<code>udev</code>策略，可以查看<code>/lib/udev/rules.d/95-ceph-osd.rules</code>得到挂载信息(centos7)，当然也可以google下<code>udev</code>策略的编写</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://opengers.github.io/ceph/deploy-a-ceph-cluster-use-ceph-deploy/" target="_blank" rel="noopener">https://opengers.github.io/ceph/deploy-a-ceph-cluster-use-ceph-deploy/</a> </p>
]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
  </entry>
  <entry>
    <title>Docker配置http代理</title>
    <url>/2019/12/22/Docker/Docker%E9%85%8D%E7%BD%AEhttp%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>
<p>　编辑配置文件，Ubuntu下是/etc/default/docker，CentOS下是/etc/sysconfig/docker。不过通过修改这两个文件来配置daemon已经是discouraged的了。不鼓励使用这种方法。</p>
<p>HTTP_PROXY=”<a href="http://127.0.0.1:1080/&quot;" target="_blank" rel="noopener">http://127.0.0.1:1080/&quot;</a><br>HTTPS_PROXY=”<a href="https://127.0.0.1:1080/&quot;" target="_blank" rel="noopener">https://127.0.0.1:1080/&quot;</a><br>export HTTP_PROXY HTTPS_PROXY</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>版权声明：本文为CSDN博主「styshoo」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/styshoo/article/details/55657714" target="_blank" rel="noopener">https://blog.csdn.net/styshoo/article/details/55657714</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>使用Docker Registry快速搭建内网镜像库</title>
    <url>/2019/04/18/Docker/%E4%BD%BF%E7%94%A8Docker-Registry%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%95%9C%E5%83%8F%E5%BA%93/</url>
    <content><![CDATA[<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>两台安装好docker环境的主机</p>
<ul>
<li>服务端：192.168.3.82 私有仓库服务器在，运行registry容器</li>
<li>客户端：192.168.3.83 测试客户端，用于上传、下载镜像文件<a id="more"></a>
</li>
</ul>
<h2 id="安装布署过程"><a href="#安装布署过程" class="headerlink" title="安装布署过程"></a>安装布署过程</h2><h5 id="下载官方registry镜像文件"><a href="#下载官方registry镜像文件" class="headerlink" title="下载官方registry镜像文件"></a>下载官方registry镜像文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# docker pull registry</span><br><span class="line">Using default tag: latest</span><br><span class="line">Trying to pull repository docker.io/library/registry ... </span><br><span class="line">latest: Pulling from docker.io/library/registry</span><br><span class="line">81033e7c1d6a: Pull complete </span><br><span class="line">b235084c2315: Pull complete </span><br><span class="line">c692f3a6894b: Pull complete </span><br><span class="line">ba2177f3a70e: Pull complete </span><br><span class="line">a8d793620947: Pull complete </span><br><span class="line">Digest: sha256:672d519d7fd7bbc7a448d17956ebeefe225d5eb27509d8dc5ce67ecb4a0bce54</span><br><span class="line">Status: Downloaded newer image for docker.io/registry:latest</span><br><span class="line">[root@master ~]# docker images |grep registry</span><br><span class="line">docker.io/registry   latest  d1fd7d86a825   5 months ago  33.3 MB</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="运行registry容器"><a href="#运行registry容器" class="headerlink" title="运行registry容器"></a>运行registry容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# mkdir /docker/registry -p</span><br><span class="line">[root@master ~]# docker run -itd -v /docker/registry/:/docker/registry -p 5000:5000 --restart=always --name registry registry:latest</span><br><span class="line">26d0b91a267f684f9da68f01d869b31dbc037ee6e7bf255d8fb435a22b857a0e</span><br><span class="line">[root@master ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE            COMMAND                  CREATED        STATUS        PORTS                    NAMES</span><br><span class="line">26d0b91a267f   registry:latest  &quot;/entrypoint.sh /e...&quot;   4 seconds ago  Up 3 seconds  0.0.0.0:5000-&gt;5000/tcp   registry</span><br><span class="line">参数说明</span><br><span class="line">1）-itd：在容器中打开一个伪终端进行交互操作，并在后台运行；</span><br><span class="line">2）-v：把宿主机的/docker/registry目录绑定到容器/docker/registry目录(这个目录是registry容器中存放镜像文件的目录)，来实现数据的持久化；</span><br><span class="line">3）-p：映射端口；访问宿主机的5000端口就访问到registry容器的服务了；</span><br><span class="line">4）--restart=always：这是重启的策略，假如这个容器异常退出会自动重启容器；</span><br><span class="line">5）--name registry：创建容器命名为registry，可自定义任何名称；</span><br><span class="line">6）registry:latest：这个是刚才pull下来的镜像；</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="查看远程仓库镜像文件"><a href="#查看远程仓库镜像文件" class="headerlink" title="查看远程仓库镜像文件"></a>查看远程仓库镜像文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# curl http://localhost:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[]&#125;</span><br><span class="line">同样也可以使用浏览器访问http://server-ip:5000/v2/_catalog, 结果相同，都是空的没有任何文件。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h2><h5 id="修改下载的镜像源"><a href="#修改下载的镜像源" class="headerlink" title="修改下载的镜像源"></a>修改下载的镜像源</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@slave1 ~]# vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">[root@slave1 ~]# systemctl restart docker</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="下载测试镜像"><a href="#下载测试镜像" class="headerlink" title="下载测试镜像"></a>下载测试镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@slave1 ~]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">Trying to pull repository docker.io/library/nginx ... </span><br><span class="line">latest: Pulling from docker.io/library/nginx</span><br><span class="line">683abbb4ea60: Pull complete </span><br><span class="line">6ff57cbc007a: Pull complete </span><br><span class="line">162f7aebbf40: Pull complete </span><br><span class="line">Digest: sha256:636dd2749d9a363e5b57557672a9ebc7c6d041c88d9aef184308d7434296feea</span><br><span class="line">Status: Downloaded newer image for docker.io/nginx:latest</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="给镜像打TAG"><a href="#给镜像打TAG" class="headerlink" title="给镜像打TAG"></a>给镜像打TAG</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@slave1 ~]# docker tag nginx:latest 192.168.3.82:5000/nginx:v1</span><br><span class="line">[root@slave1 ~]# docker images</span><br><span class="line">REPOSITORY                TAG       IMAGE ID        CREATED       SIZE</span><br><span class="line">192.168.3.82:5000/nginx   v1        649dcb69b782    8 hours ago   109 MB</span><br><span class="line">docker.io/nginx           latest    649dcb69b782    8 hours ago   109 MB</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@slave1 ~]# docker push 192.168.3.82:5000/nginx:v1</span><br><span class="line">The push refers to a repository [192.168.3.82:5000/nginx]</span><br><span class="line">Get https://192.168.3.82:5000/v1/_ping: http: server gave HTTP response to HTTPS client</span><br><span class="line">#注意这里出现报错提示，从提示信息可以看出需要使用https的方式才能上传，解决方案如下：</span><br><span class="line">[root@slave1 ~]# vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;],</span><br><span class="line"> &quot;insecure-registries&quot;:[&quot;192.168.3.82:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line">#添加私有镜像服务器的地址，注意书写格式为json，有严格的书写要求，需要重启docker服务生效配置</span><br><span class="line">[root@slave1 ~]# systemctl restart docker</span><br><span class="line">[root@slave1 ~]# docker push 192.168.3.82:5000/nginx:v1</span><br><span class="line">The push refers to a repository [192.168.3.82:5000/nginx]</span><br><span class="line">6ee5b085558c: Pushed </span><br><span class="line">78f25536dafc: Pushed </span><br><span class="line">9c46f426bcb7: Pushed </span><br><span class="line">v1: digest: sha256:edad5e71815c79108ddbd1d42123ee13ba2d8050ad27cfa72c531986d03ee4e7 size: 948</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="重新查看镜像仓库"><a href="#重新查看镜像仓库" class="headerlink" title="重新查看镜像仓库"></a>重新查看镜像仓库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# curl http://localhost:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;nginx&quot;]&#125;</span><br><span class="line">[root@master ~]# curl http://localhost:5000/v2/nginx/tags/list</span><br><span class="line">&#123;&quot;name&quot;:&quot;nginx&quot;,&quot;tags&quot;:[&quot;v1&quot;]&#125;</span><br><span class="line">#查看有哪些版本</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="测试下载"><a href="#测试下载" class="headerlink" title="测试下载"></a>测试下载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#首先删除客户端主机之前从公共库下载下来的镜像文件</span><br><span class="line">[root@slave1 ~]# docker images</span><br><span class="line">REPOSITORY                TAG      IMAGE ID        CREATED        SIZE</span><br><span class="line">192.168.3.82:5000/nginx   v1       649dcb69b782    10 hours ago   109 MB</span><br><span class="line">docker.io/nginx           latest   649dcb69b782    10 hours ago   109 MB</span><br><span class="line">[root@slave1 ~]# docker image rmi -f 649dcb69b782</span><br><span class="line">Untagged: 192.168.3.82:5000/nginx:v1</span><br><span class="line">Untagged: 192.168.3.82:5000/nginx@sha256:edad5e71815c79108ddbd1d42123ee13ba2d8050ad27cfa72c531986d03ee4e7</span><br><span class="line">Untagged: docker.io/nginx:latest</span><br><span class="line">Untagged: docker.io/nginx@sha256:636dd2749d9a363e5b57557672a9ebc7c6d041c88d9aef184308d7434296feea</span><br><span class="line">Deleted: sha256:649dcb69b782d4e281c92ed2918a21fa63322a6605017e295ea75907c84f4d1e</span><br><span class="line">Deleted: sha256:bf7cb208a5a1da265666ad5ab3cf10f0bec1f4bcb0ba8d957e2e485e3ac2b463</span><br><span class="line">Deleted: sha256:55d02c20aa07136ab07ab47f4b20b97be7a0f34e01a88b3e046a728863b5621c</span><br><span class="line">Deleted: sha256:9c46f426bcb704beffafc951290ee7fe05efddbc7406500e7d0a3785538b8735</span><br><span class="line">[root@slave1 ~]# docker images</span><br><span class="line">REPOSITORY       TAG             IMAGE ID        CREATED         SIZE</span><br><span class="line">#此时客户端所有的镜像文件全部删除</span><br><span class="line">[root@slave1 ~]# docker pull 192.168.3.82:5000/nginx:v1</span><br><span class="line">Trying to pull repository 192.168.3.82:5000/nginx ... </span><br><span class="line">v1: Pulling from 192.168.3.82:5000/nginx</span><br><span class="line">683abbb4ea60: Pull complete </span><br><span class="line">6ff57cbc007a: Pull complete </span><br><span class="line">162f7aebbf40: Pull complete </span><br><span class="line">Digest: sha256:edad5e71815c79108ddbd1d42123ee13ba2d8050ad27cfa72c531986d03ee4e7</span><br><span class="line">Status: Downloaded newer image for 192.168.3.82:5000/nginx:v1</span><br><span class="line">[root@slave1 ~]# docker images</span><br><span class="line">REPOSITORY                TAG     IMAGE ID       CREATED         SIZE</span><br><span class="line">192.168.3.82:5000/nginx   v1      649dcb69b782   11 hours ago    109 MB</span><br><span class="line">#可以看出，客户端已正常从远端服务器拉取到所需要的镜像文件，其它内网服务器也可以正常共享这台镜像服务器上的镜像文件，不用去公网拉取。</span><br></pre></td></tr></table></figure>
<h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h6><p>使用docker Registry快速搭建私有镜像仓库</p>
<p><a href="https://juejin.im/post/5bbbf72c5188255c554710ca" target="_blank" rel="noopener">https://juejin.im/post/5bbbf72c5188255c554710ca</a> </p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker常用操作</title>
    <url>/2019/04/18/Docker/Docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h5 id="查看Docker容器的启动命令"><a href="#查看Docker容器的启动命令" class="headerlink" title="查看Docker容器的启动命令"></a>查看Docker容器的启动命令</h5><p>运行中的容器，<code>docker inspect container</code></p>
<h5 id="实时查看docker容器名为s12的最后10行日志"><a href="#实时查看docker容器名为s12的最后10行日志" class="headerlink" title="实时查看docker容器名为s12的最后10行日志"></a>实时查看docker容器名为s12的最后10行日志</h5><p>$ sudo docker logs -f -t –tail 10 s12</p>
<a id="more"></a>
<p>从Rancher网站下载Docker-CE</p>
<p>curl <a href="https://releases.rancher.com/install-docker/17.06.2.sh" target="_blank" rel="noopener">https://releases.rancher.com/install-docker/17.06.2.sh</a> | sh</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>解决 Docker容器启动报 IPv4 forwarding is disabled 的问题</title>
    <url>/2019/04/18/Docker/%E8%A7%A3%E5%86%B3Docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%8A%A5IPv4/</url>
    <content><![CDATA[<p>解决办法：</p>
<p># vi /etc/sysctl.conf</p>
<p>或者</p>
<p># vi /usr/lib/sysctl.d/00-system.conf</p>
<p>添加如下代码：</p>
<p>​    net.ipv4.ip_forward=1</p>
<p>重启network服务</p>
<p># systemctl restart network</p>
<p>查看是否修改成功</p>
<p># sysctl net.ipv4.ip_forward</p>
<p>如果返回为“net.ipv4.ip_forward = 1”则表示成功了</p>
<p>这时，重启容器即可。</p>
<p>另外还可以通过run时加-p 参数指定IP的方式来解决，比如 -p 0.0.0.0:999:999（指定ip就按ipv4来，否则默认全部是ipv6的。）</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>修改docker镜像重新打包</title>
    <url>/2019/06/12/Docker/%E4%BF%AE%E6%94%B9docker%E9%95%9C%E5%83%8F%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>更新镜像之前，我们需要使用镜像来创建一个容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash</span><br><span class="line">root@e218edb10161:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>在运行的容器内使用 apt-get update 命令进行更新。</p>
<p>在完成操作之后，输入 exit命令来退出这个容器。</p>
<p>此时ID为e218edb10161的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -m=<span class="string">"has update"</span> -a=<span class="string">"runoob"</span> e218edb10161 runoob/ubuntu:v2</span><br><span class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</span><br></pre></td></tr></table></figure>
<p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong>提交的描述信息</li>
<li><strong>-a:</strong>指定镜像作者</li>
<li><strong>e218edb10161：</strong>容器ID</li>
<li><strong>runoob/ubuntu:v2:</strong>指定要创建的目标镜像名</li>
</ul>
<p>我们可以使用 <strong>docker images</strong> 命令来查看我们的新镜像 <strong>runoob/ubuntu:v2</strong>：</p>
<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.runoob.com/docker/docker-image-usage.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-image-usage.html</a> </p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Go Map、Slice线程安全研究以及append内存重复利用</title>
    <url>/2019/06/28/Go/Go-Map%E3%80%81Slice%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E4%BB%A5%E5%8F%8Aappend%E5%86%85%E5%AD%98%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>sync.Map存的是值</p>
<p>Slice是引用类型</p>
<p>sync.Pool是引用类型</p>
<a id="more"></a>
<h2 id="sync-Map存的是值"><a href="#sync-Map存的是值" class="headerlink" title="sync.Map存的是值"></a>sync.Map存的是值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">	persons := <span class="number">4</span></span><br><span class="line">	syncMap.Store(<span class="number">666</span>, persons)</span><br><span class="line">	aa, _ := syncMap.Load(<span class="number">666</span>)</span><br><span class="line">	fmt.Println(aa)</span><br><span class="line">	bb, _ := syncMap.Load(<span class="number">666</span>)</span><br><span class="line">	bb = <span class="number">8</span></span><br><span class="line">	fmt.Println(bb)</span><br><span class="line">	fmt.Println(aa)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>模拟多线程修改从sync.Map中Load的值，修改是隔离的，aa未被修改。对于Struct也是如此：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	personA:= person&#123;</span><br><span class="line">		<span class="number">169</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	syncMap.Store(<span class="number">666</span>,personA)</span><br><span class="line">	aa, _ := syncMap.Load(<span class="number">666</span>)</span><br><span class="line">	fmt.Println(aa.(person).Height)</span><br><span class="line">	bb, _ := syncMap.Load(<span class="number">666</span>)</span><br><span class="line">	anPerson := bb.(person)</span><br><span class="line">	anPerson.Height = <span class="number">159</span></span><br><span class="line">	fmt.Println(bb.(person).Height)</span><br><span class="line">	fmt.Println(aa.(person).Height)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="number">169</span></span><br><span class="line"><span class="number">169</span></span><br><span class="line"><span class="number">169</span></span><br></pre></td></tr></table></figure>
<h2 id="Slice是引用类型"><a href="#Slice是引用类型" class="headerlink" title="Slice是引用类型"></a>Slice是引用类型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	persons := <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">	persons[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	persons[<span class="number">1</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">169</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	syncMap.Store(<span class="number">666</span>, persons)</span><br><span class="line">	aa, _ := syncMap.Load(<span class="number">666</span>)</span><br><span class="line">	fmt.Println((aa.([]Person))[<span class="number">0</span>].Height)</span><br><span class="line">	bb, _ := syncMap.Load(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">	(bb.([]Person))[<span class="number">0</span>].Height = <span class="number">90</span></span><br><span class="line"></span><br><span class="line">	fmt.Println((bb.([]Person))[<span class="number">0</span>].Height)</span><br><span class="line">	fmt.Println((aa.([]Person))[<span class="number">0</span>].Height)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="number">159</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">90</span></span><br></pre></td></tr></table></figure>
<p>在不同线程中修改从sync.Map中Load的Slice，修改是非隔离的。例如在其他线程修改了bb，aa也会受影响</p>
<h2 id="sync-Pool是引用类型"><a href="#sync-Pool是引用类型" class="headerlink" title="sync.Pool是引用类型"></a>sync.Pool是引用类型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changePool</span><span class="params">(pool sync.Pool)</span></span> &#123;</span><br><span class="line">	tmp := pool.Get()</span><br><span class="line">	fmt.Println(tmp)</span><br><span class="line">	<span class="comment">//pool.Put(tmp)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	aPool := sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	persons := <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">	persons[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	persons[<span class="number">1</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">169</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	aPool.Put(persons)</span><br><span class="line">	changePool(aPool)</span><br><span class="line">	newPersons:= aPool.Get()</span><br><span class="line">	fmt.Println(newPersons)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">[&#123;<span class="number">159</span>&#125; &#123;<span class="number">169</span>&#125;]</span><br><span class="line">[&#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>在changePool中取出元素，在main函数中再次Get，会调用make生成元素</p>
<h2 id="在sync-Pool中存Slice对象还是地址？"><a href="#在sync-Pool中存Slice对象还是地址？" class="headerlink" title="在sync.Pool中存Slice对象还是地址？"></a>在sync.Pool中存Slice对象还是地址？</h2><p>我们来测试在一个sync.Pool中存Slice对象地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOnlyCheckIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 测试仅放回池，不放回sync.Map</span></span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	newPool, _ := syncMap.LoadOrStore(<span class="number">2</span>, sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> &amp;slice</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">var</span> aPool = newPool.(sync.Pool)</span><br><span class="line">	aObj := aPool.Get().(*[]Person)</span><br><span class="line">	(*aObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"a初始值："</span>, aObj)</span><br><span class="line">	aPool.Put(aObj)</span><br><span class="line">	bObj := aPool.Get().(*[]Person)</span><br><span class="line">	fmt.Println(<span class="string">"b初始值："</span>, bObj)</span><br><span class="line">	(*bObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">90</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"b修改后值："</span>, bObj)</span><br><span class="line">	fmt.Println(<span class="string">"a修改后值："</span>, aObj)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">a初始值： &amp;[&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b初始值： &amp;[&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b修改后值： &amp;[&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">a修改后值： &amp;[&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>可以看到，假如b线程从sync.Pool里取出地址并修改对象的值，a线程先前存入的对象会被修改。假如存入地址的对象还在使用，就会出现问题。再次放回sync.Map里也是如此</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCheckIntoMapAndCheckOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 测试放回池，放回sync.Map后，再依次取出</span></span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	newPool, _ := syncMap.LoadOrStore(<span class="number">2</span>, sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> &amp;slice</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">var</span> aPool = newPool.(sync.Pool)</span><br><span class="line">	aObj := aPool.Get().(*[]Person)</span><br><span class="line">	(*aObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"a初始值："</span>, aObj)</span><br><span class="line">	aPool.Put(aObj)</span><br><span class="line">	syncMap.Store(<span class="number">2</span>, aPool)</span><br><span class="line"></span><br><span class="line">	newPool2, _ := syncMap.Load(<span class="number">2</span>)</span><br><span class="line">	bPool := newPool2.(sync.Pool)</span><br><span class="line">	bObj := bPool.Get().(*[]Person)</span><br><span class="line">	fmt.Println(<span class="string">"b初始值："</span>, bObj)</span><br><span class="line">	(*bObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">90</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"b修改后值："</span>, bObj)</span><br><span class="line">	fmt.Println(<span class="string">"a修改后值："</span>, aObj)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">a初始值： &amp;[&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b初始值： &amp;[&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b修改后值： &amp;[&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">a修改后值： &amp;[&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>那么sync.Pool直接存Slice对象行不行呢？我们来看一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSafeWayToUseSyncPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// sync.Pool 存对象，而不是存其地址</span></span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	newPool, _ := syncMap.LoadOrStore(<span class="number">2</span>, sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">var</span> aPool = newPool.(sync.Pool)</span><br><span class="line">	aObj := aPool.Get().([]Person)</span><br><span class="line">	(aObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"a初始值："</span>, aObj)</span><br><span class="line">	aPool.Put(aObj)</span><br><span class="line">	syncMap.Store(<span class="number">2</span>, aPool)</span><br><span class="line"></span><br><span class="line">	newPool2, _ := syncMap.Load(<span class="number">2</span>)</span><br><span class="line">	bPool := newPool2.(sync.Pool)</span><br><span class="line">	bObj := bPool.Get().([]Person)</span><br><span class="line">	fmt.Println(<span class="string">"b初始值："</span>, bObj)</span><br><span class="line">	(bObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">90</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"b修改后值："</span>, bObj)</span><br><span class="line">	fmt.Println(<span class="string">"a修改后值："</span>, aObj)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">a初始值： &amp;[&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b初始值： &amp;[&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b修改后值： &amp;[&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">a修改后值： &amp;[&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>并没有和我们想的一样，b的修改不影响a。因为Slice是引用类型，除非是deepCopy，否则对Slice修改，都是修改其内容。这就很危险了，不过要手动回收垃圾，这倒是简便的写法。</p>
<p>确保Slice不会再次使用时，把它放到sync.Pool里，再次取出时直接往Slice里写，这时候是写入老的内存地址中。</p>
<p>有一个隐藏的严重问题。sync.Pool有没有可能是单例？我在sync.Map里存多个sync.Pool是否有效？下面测试一下。</p>
<h2 id="测试能否建立多个互不影响的sync-Pool"><a href="#测试能否建立多个互不影响的sync-Pool" class="headerlink" title="测试能否建立多个互不影响的sync.Pool"></a>测试能否建立多个互不影响的sync.Pool</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMutiSyncPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 测试建立多个互不影响的sync.Pool</span></span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poolWithLen2 := sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;&#125;</span><br><span class="line">	poolWithLen4 := sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;&#125;</span><br><span class="line">	aObj := poolWithLen2.Get().([]Person)</span><br><span class="line">	(aObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"a初始值："</span>, aObj)</span><br><span class="line">	poolWithLen2.Put(aObj)</span><br><span class="line">	bObj := poolWithLen4.Get().([]Person)</span><br><span class="line">	fmt.Println(<span class="string">"b初始值："</span>, bObj)</span><br><span class="line">	aObj = poolWithLen2.Get().([]Person)</span><br><span class="line">	fmt.Println(<span class="string">"重新取出a打印："</span>, aObj)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">a初始值： [&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b初始值： [&#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">重新取出a打印： [&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>可喜可贺，sync.Pool支持多个且互不影响。我们可以把不同长度的Person Slice存到一个sync.Map以充分利用内存。</p>
<p>这里其实还忽视了一个隐藏的问题。虽然sync.Pool是引用类型，作为sync.Map值时却不是传引用。下面验证一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSafeWayToUseSyncPoolAndMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 验证sync.Pool作为sync.Map值时不是传引用</span></span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	newPool, _ := syncMap.LoadOrStore(<span class="number">2</span>, sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">var</span> aPool = newPool.(sync.Pool)</span><br><span class="line">	aObj := aPool.Get().([]Person)</span><br><span class="line">	(aObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"a初始值："</span>, aObj)</span><br><span class="line">	aPool.Put(aObj)</span><br><span class="line">	fmt.Println(<span class="string">"这里不把aPool存回sync.Map"</span>)</span><br><span class="line"></span><br><span class="line">	newPool2, _ := syncMap.Load(<span class="number">2</span>)</span><br><span class="line">	bPool := newPool2.(sync.Pool)</span><br><span class="line">	bObj := bPool.Get().([]Person)</span><br><span class="line">	fmt.Println(<span class="string">"b初始值："</span>, bObj)</span><br><span class="line">	(bObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">90</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"b修改后值："</span>, bObj)</span><br><span class="line">	fmt.Println(<span class="string">"a修改后值："</span>, aObj)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">a初始值： [&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">这里不把aPool存回sync.Map</span><br><span class="line">b初始值： [&#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b修改后值： [&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">a修改后值： [&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>悲剧，如果不把Pool存回Map，在外面对Pool的修改是不生效的，如果Pool在Map里存的是地址呢？我们再看一下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNotPutPoolIntoMapButUsePtr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// sync.Pool作为sync.Map值时传引用</span></span><br><span class="line">	<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">		Height <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	newPool, _ := syncMap.LoadOrStore(<span class="number">2</span>, &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">var</span> aPool = newPool.(*sync.Pool)</span><br><span class="line">	aObj := aPool.Get().([]Person)</span><br><span class="line">	(aObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">159</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"a初始值："</span>, aObj)</span><br><span class="line">	aPool.Put(aObj)</span><br><span class="line">	fmt.Println(<span class="string">"这里不把aPool存回sync.Map"</span>)</span><br><span class="line"></span><br><span class="line">	newPool2, _ := syncMap.Load(<span class="number">2</span>)</span><br><span class="line">	bPool := newPool2.(*sync.Pool)</span><br><span class="line">	bObj := bPool.Get().([]Person)</span><br><span class="line">	fmt.Println(<span class="string">"b初始值："</span>, bObj)</span><br><span class="line">	(bObj)[<span class="number">0</span>] = Person&#123;</span><br><span class="line">		Height: <span class="number">90</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"b修改后值："</span>, bObj)</span><br><span class="line">	fmt.Println(<span class="string">"a修改后值："</span>, aObj)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">a初始值： [&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">这里不把aPool存回sync.Map</span><br><span class="line">b初始值： [&#123;<span class="number">159</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">b修改后值： [&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">a修改后值： [&#123;<span class="number">90</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>真棒！sync.Pool可以在各线程中共享值而不必放回sync.Map！</p>
<h2 id="sync-Pool收集内存的正确使用方式"><a href="#sync-Pool收集内存的正确使用方式" class="headerlink" title="sync.Pool收集内存的正确使用方式"></a>sync.Pool收集内存的正确使用方式</h2><p>来走一遍收集内存的流程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGCinAppend</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 测试优化的append</span></span><br><span class="line">	fmt.Println(<span class="string">"申请一个长度为2的Slice"</span>)</span><br><span class="line">	slice2 := []Person&#123;</span><br><span class="line">		&#123;<span class="number">234</span>&#125;,</span><br><span class="line">		&#123;<span class="number">456</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"slice2初始值："</span>, slice2)</span><br><span class="line">	fmt.Println(<span class="string">"append长度不够，申请一个长度为4的Slice，同时把老Slice存入Map"</span>)</span><br><span class="line"></span><br><span class="line">	getPool, _ := syncMap.LoadOrStore(<span class="number">4</span>, &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;&#125;)</span><br><span class="line">	poolWithLen4 := getPool.(*sync.Pool)</span><br><span class="line">	newSlice := poolWithLen4.Get().([]Person)</span><br><span class="line">	fmt.Println(<span class="string">"新的slice2初始值："</span>, newSlice)</span><br><span class="line">	<span class="built_in">copy</span>(newSlice, slice2)</span><br><span class="line">	fmt.Printf(<span class="string">"#注意这行 把slice2拷到新的slice2后，新的slice2的值：%v，新的slice2长度：%d、容量：%d\n"</span>, newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	newSlice = newSlice[:<span class="number">2</span>]</span><br><span class="line">	fmt.Printf(<span class="string">"Slice截长度之后，新的slice2的值：%v，新的slice2长度：%d、容量：%d\n"</span>, newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	fmt.Println(<span class="string">"把老的Slice存入Map"</span>)</span><br><span class="line">	getPool, _ = syncMap.LoadOrStore(<span class="number">2</span>, &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;&#125;)</span><br><span class="line">	poolWithLen2 := getPool.(*sync.Pool)</span><br><span class="line">	poolWithLen2.Put(slice2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"把新的Slice赋值给slice2"</span>)</span><br><span class="line">	slice2 = newSlice</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice2的值：%v，slice2长度：%d、容量：%d\n"</span>, slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"打印poolWithLen2内容"</span>)</span><br><span class="line">	PrintPool(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">"打印poolWithLen4内容"</span>)</span><br><span class="line">	PrintPool(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"只有一个元素的slice1 append，用前面申请的内存"</span>)</span><br><span class="line">	slice1 := []Person&#123;</span><br><span class="line">		&#123;<span class="number">888</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	getPool, _ = syncMap.LoadOrStore(<span class="number">2</span>, &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;&#125;)</span><br><span class="line">	poolWithLen2 = getPool.(*sync.Pool)</span><br><span class="line">	newSlice = poolWithLen2.Get().([]Person)</span><br><span class="line">	fmt.Println(<span class="string">"新的slice1初始值："</span>, newSlice)</span><br><span class="line">	<span class="built_in">copy</span>(newSlice, slice1)</span><br><span class="line">	fmt.Printf(<span class="string">"#注意这行 把slice1拷到新的slice1后，新的slice1的值：%v，slice4长度：%d、容量：%d\n"</span>, newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	newSlice = newSlice[:<span class="number">1</span>]</span><br><span class="line">	fmt.Printf(<span class="string">"Slice截长度之后，新的slice1的值：%v，slice4长度：%d、容量：%d\n"</span>, newSlice, <span class="built_in">len</span>(newSlice), <span class="built_in">cap</span>(newSlice))</span><br><span class="line">	fmt.Println(<span class="string">"把老的Slice存入Map"</span>)</span><br><span class="line">	getPool, _ = syncMap.LoadOrStore(<span class="number">1</span>, &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;&#125;)</span><br><span class="line">	poolWithLen1 := getPool.(*sync.Pool)</span><br><span class="line">	poolWithLen1.Put(slice1)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"把新的Slice赋值给slice1"</span>)</span><br><span class="line">	slice1 = newSlice</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice1的值：%v，slice1长度：%d、容量：%d\n"</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"打印poolWithLen1内容"</span>)</span><br><span class="line">	PrintPool(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="string">"打印poolWithLen2内容"</span>)</span><br><span class="line">	PrintPool(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">"打印poolWithLen4内容"</span>)</span><br><span class="line">	PrintPool(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintPool</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> objCollect [][]Person</span><br><span class="line">	getPool, _ := syncMap.Load(i)</span><br><span class="line">	aPool := getPool.(*sync.Pool)</span><br><span class="line">	<span class="keyword">for</span> ; ; &#123;</span><br><span class="line">		aObj := aPool.Get().([]Person)</span><br><span class="line">		<span class="keyword">if</span> (aObj)[<span class="number">0</span>].Height == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"打印Pool中的元素：%v\n"</span>, aObj)</span><br><span class="line">		objCollect = <span class="built_in">append</span>(objCollect, aObj)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, x := <span class="keyword">range</span> objCollect &#123;</span><br><span class="line">		aPool.Put(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">申请一个长度为<span class="number">2</span>的Slice</span><br><span class="line">slice2初始值： [&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125;]</span><br><span class="line"><span class="built_in">append</span>长度不够，申请一个长度为<span class="number">4</span>的Slice，同时把老Slice存入Map</span><br><span class="line">新的slice2初始值： [&#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125;]</span><br><span class="line">#注意这行 把slice2拷到新的slice2后，新的slice2的值：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125; &#123;<span class="number">0</span>&#125; &#123;<span class="number">0</span>&#125;]，新的slice2长度：<span class="number">4</span>、容量：<span class="number">4</span></span><br><span class="line">Slice截长度之后，新的slice2的值：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125;]，新的slice2长度：<span class="number">2</span>、容量：<span class="number">4</span></span><br><span class="line">把老的Slice存入Map</span><br><span class="line">把新的Slice赋值给slice2</span><br><span class="line">现在slice2的值：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125;]，slice2长度：<span class="number">2</span>、容量：<span class="number">4</span></span><br><span class="line">打印poolWithLen2内容</span><br><span class="line">打印Pool中的元素：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125;]</span><br><span class="line">打印poolWithLen4内容</span><br><span class="line">只有一个元素的slice1 <span class="built_in">append</span>，用前面申请的内存</span><br><span class="line"></span><br><span class="line">新的slice1初始值： [&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125;]</span><br><span class="line">#注意这行 把slice1拷到新的slice1后，新的slice1的值：[&#123;<span class="number">888</span>&#125; &#123;<span class="number">456</span>&#125;]，slice4长度：<span class="number">2</span>、容量：<span class="number">2</span></span><br><span class="line">Slice截长度之后，新的slice1的值：[&#123;<span class="number">888</span>&#125;]，slice4长度：<span class="number">1</span>、容量：<span class="number">2</span></span><br><span class="line">把老的Slice存入Map</span><br><span class="line">把新的Slice赋值给slice1</span><br><span class="line">现在slice1的值：[&#123;<span class="number">888</span>&#125;]，slice1长度：<span class="number">1</span>、容量：<span class="number">2</span></span><br><span class="line">打印poolWithLen1内容</span><br><span class="line">打印Pool中的元素：[&#123;<span class="number">888</span>&#125;]</span><br><span class="line">打印poolWithLen2内容</span><br><span class="line">打印poolWithLen4内容</span><br></pre></td></tr></table></figure>
<p>写对不容易，忽略一堆魔鬼变量取名T T。精简一下，得到最终测试代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtraAppend</span><span class="params">(personSlice *[]Person, newObj Person)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> personSlice != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(*personSlice) == <span class="built_in">cap</span>(*personSlice) &#123;</span><br><span class="line">		oldLength := <span class="built_in">len</span>(*personSlice)</span><br><span class="line">		getPool, _ := syncMap.LoadOrStore(oldLength*<span class="number">2</span>, &amp;sync.Pool&#123;</span><br><span class="line">			New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">				<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, oldLength*<span class="number">2</span>)</span><br><span class="line">				<span class="keyword">return</span> slice</span><br><span class="line">			&#125;&#125;)</span><br><span class="line">		poolWithLenDouble := getPool.(*sync.Pool)</span><br><span class="line">		newSlice := poolWithLenDouble.Get().([]Person)</span><br><span class="line">		<span class="built_in">copy</span>(newSlice, *personSlice)</span><br><span class="line">		newSlice = newSlice[:oldLength]</span><br><span class="line">		getPool, _ = syncMap.LoadOrStore(oldLength, &amp;sync.Pool&#123;</span><br><span class="line">			New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">				<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, oldLength)</span><br><span class="line">				<span class="keyword">return</span> slice</span><br><span class="line">			&#125;&#125;)</span><br><span class="line">		poolWithLenOrigin := getPool.(*sync.Pool)</span><br><span class="line">		poolWithLenOrigin.Put(*personSlice)</span><br><span class="line">		*personSlice = newSlice</span><br><span class="line">		fmt.Println(<span class="string">"扩容完毕"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	*personSlice = <span class="built_in">append</span>(*personSlice, newObj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExtraAppend</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice2 := []Person&#123;</span><br><span class="line">		&#123;<span class="number">234</span>&#125;,</span><br><span class="line">		&#123;<span class="number">456</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	ExtraAppend(&amp;slice2, Person&#123;</span><br><span class="line">		<span class="number">555</span>,&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice2的值：%v，slice2长度：%d、容量：%d\n"</span>, slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line">	slice1 := []Person&#123;</span><br><span class="line">		&#123;<span class="number">888</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	ExtraAppend(&amp;slice1, Person&#123;</span><br><span class="line">		<span class="number">8911</span>,&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice1的值：%v，slice1长度：%d、容量：%d\n"</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice2的值：%v，slice2长度：%d、容量：%d\n"</span>, slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line">	PrintPool(<span class="number">1</span>)</span><br><span class="line">	PrintPool(<span class="number">2</span>)</span><br><span class="line">	PrintPool(<span class="number">3</span>)</span><br><span class="line">	PrintPool(<span class="number">4</span>)</span><br><span class="line">	fmt.Println(<span class="string">"执行一次runtime.GC()"</span>)</span><br><span class="line">	runtime.GC()</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice2的值：%v，slice2长度：%d、容量：%d\n"</span>, slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice1的值：%v，slice1长度：%d、容量：%d\n"</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br><span class="line">	PrintPool(<span class="number">1</span>)</span><br><span class="line">	PrintPool(<span class="number">2</span>)</span><br><span class="line">	PrintPool(<span class="number">3</span>)</span><br><span class="line">	PrintPool(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintPool</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"打印Pool中的元素，长度为：%d\n"</span>, i)</span><br><span class="line">	<span class="keyword">var</span> objCollect [][]Person</span><br><span class="line">	getPool, _ := syncMap.LoadOrStore(i, &amp;sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, i)</span><br><span class="line">			<span class="keyword">return</span> slice</span><br><span class="line">		&#125;&#125;)</span><br><span class="line">	aPool := getPool.(*sync.Pool)</span><br><span class="line">	<span class="keyword">for</span> ; ; &#123;</span><br><span class="line">		aObj := aPool.Get().([]Person)</span><br><span class="line">		<span class="keyword">if</span> (aObj)[<span class="number">0</span>].Height == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"元素：%v，元素长度：%d、容量：%d\n"</span>, aObj, <span class="built_in">len</span>(aObj), <span class="built_in">cap</span>(aObj))</span><br><span class="line">		objCollect = <span class="built_in">append</span>(objCollect, aObj)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, x := <span class="keyword">range</span> objCollect &#123;</span><br><span class="line">		aPool.Put(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">扩容完毕</span><br><span class="line">现在slice2的值：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125; &#123;<span class="number">555</span>&#125;]，slice2长度：<span class="number">3</span>、容量：<span class="number">4</span></span><br><span class="line">扩容完毕</span><br><span class="line">现在slice1的值：[&#123;<span class="number">888</span>&#125; &#123;<span class="number">8911</span>&#125;]，slice1长度：<span class="number">2</span>、容量：<span class="number">2</span></span><br><span class="line">现在slice2的值：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125; &#123;<span class="number">555</span>&#125;]，slice2长度：<span class="number">3</span>、容量：<span class="number">4</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">1</span></span><br><span class="line">元素：[&#123;<span class="number">888</span>&#125;]，元素长度：<span class="number">1</span>、容量：<span class="number">1</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">2</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">3</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">4</span></span><br><span class="line">执行一次runtime.GC()</span><br><span class="line">现在slice2的值：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125; &#123;<span class="number">555</span>&#125;]，slice2长度：<span class="number">3</span>、容量：<span class="number">4</span></span><br><span class="line">现在slice1的值：[&#123;<span class="number">888</span>&#125; &#123;<span class="number">8911</span>&#125;]，slice1长度：<span class="number">2</span>、容量：<span class="number">2</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">1</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">2</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">3</span></span><br><span class="line">打印Pool中的元素，长度为：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>每次系统GC，会带走所有sync.Pool中的元素。下面是第一版错误的例子23333</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExtraAppend</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice2 := []Person&#123;</span><br><span class="line">		&#123;<span class="number">234</span>&#125;,</span><br><span class="line">		&#123;<span class="number">456</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	ExtraAppendFailed(&amp;slice2, Person&#123;</span><br><span class="line">		<span class="number">555</span>,&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice2的值：%v，slice2长度：%d、容量：%d\n"</span>, slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line">	slice1 := []Person&#123;</span><br><span class="line">		&#123;<span class="number">888</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	ExtraAppendFailed(&amp;slice1, Person&#123;</span><br><span class="line">		<span class="number">8911</span>,&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"现在slice1的值：%v，slice1长度：%d、容量：%d\n"</span>, slice1, <span class="built_in">len</span>(slice1), <span class="built_in">cap</span>(slice1))</span><br><span class="line">	fmt.Printf(<span class="string">"现在slice2的值：%v，slice2长度：%d、容量：%d\n"</span>, slice2, <span class="built_in">len</span>(slice2), <span class="built_in">cap</span>(slice2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtraAppendFailed</span><span class="params">(personSlice *[]Person, newObj Person)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> personSlice != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(*personSlice) == <span class="built_in">cap</span>(*personSlice) &#123;</span><br><span class="line">		oldLength := <span class="built_in">len</span>(*personSlice)</span><br><span class="line">		getPool, _ := syncMap.LoadOrStore(oldLength*<span class="number">2</span>, &amp;sync.Pool&#123;</span><br><span class="line">			New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">				<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, oldLength*<span class="number">2</span>)</span><br><span class="line">				<span class="keyword">return</span> &amp;slice</span><br><span class="line">			&#125;&#125;)</span><br><span class="line">		poolWithLenDouble := getPool.(*sync.Pool)</span><br><span class="line">		newSlice := poolWithLenDouble.Get().(*[]Person)</span><br><span class="line">		<span class="built_in">copy</span>(*newSlice, *personSlice)</span><br><span class="line">		<span class="keyword">var</span> tmpSlice = *newSlice</span><br><span class="line">		*newSlice = tmpSlice[:oldLength]</span><br><span class="line">		getPool, _ = syncMap.LoadOrStore(oldLength, &amp;sync.Pool&#123;</span><br><span class="line">			New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">				<span class="keyword">var</span> slice = <span class="built_in">make</span>([]Person, oldLength)</span><br><span class="line">				<span class="keyword">return</span> &amp;slice</span><br><span class="line">			&#125;&#125;)</span><br><span class="line">		poolWithLenOrigin := getPool.(*sync.Pool)</span><br><span class="line">		poolWithLenOrigin.Put(personSlice)</span><br><span class="line">		*personSlice = *newSlice</span><br><span class="line">		fmt.Println(<span class="string">"扩容完毕"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	*personSlice = <span class="built_in">append</span>(*personSlice, newObj)</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line">扩容完毕</span><br><span class="line">现在slice2的值：[&#123;<span class="number">234</span>&#125; &#123;<span class="number">456</span>&#125; &#123;<span class="number">555</span>&#125;]，slice2长度：<span class="number">3</span>、容量：<span class="number">4</span></span><br><span class="line">扩容完毕</span><br><span class="line">现在slice1的值：[&#123;<span class="number">888</span>&#125; &#123;<span class="number">8911</span>&#125;]，slice1长度：<span class="number">2</span>、容量：<span class="number">4</span></span><br><span class="line">现在slice2的值：[&#123;<span class="number">888</span>&#125;]，slice2长度：<span class="number">1</span>、容量：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>Pool里存对象地址，在第一轮append的时候，slice2的内容变成了长度4的Slice，导致slice1拿到的newSlice出错。并且对newSlice修改之后，还会改动slice2的内容。这是非常严重的运行时错误。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Go 执行单测</title>
    <url>/2019/05/12/Go/Go-%E6%89%A7%E8%A1%8C%E5%8D%95%E6%B5%8B/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -run Foo     # Run top-level tests matching <span class="string">"Foo"</span>, such as <span class="string">"TestFooBar"</span>.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Go 字符串操作</title>
    <url>/2019/06/03/Go/Go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>go语言string、int、int64互相转换</title>
    <url>/2019/05/11/Go/go%E8%AF%AD%E8%A8%80string%E3%80%81int%E3%80%81int64%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">string</span>到<span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span>,err:=strconv.Atoi(<span class="keyword">string</span>)</span><br><span class="line">#<span class="keyword">string</span>到<span class="keyword">int64</span></span><br><span class="line"><span class="keyword">int64</span>, err := strconv.ParseInt(<span class="keyword">string</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">#<span class="keyword">int</span>到<span class="keyword">string</span></span><br><span class="line"><span class="keyword">string</span>:=strconv.Itoa(<span class="keyword">int</span>)</span><br><span class="line">#<span class="keyword">int64</span>到<span class="keyword">string</span></span><br><span class="line"><span class="keyword">string</span>:=strconv.FormatInt(<span class="keyword">int64</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>作者：三少GG<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/pkueecser/article/details/50433460" target="_blank" rel="noopener">https://blog.csdn.net/pkueecser/article/details/50433460</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>go select与channel操作</title>
    <url>/2020/07/28/Go/go-select%E4%B8%8Echannel%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>select和switch类似，不同的是case内容必须是接收io执行结果（例如&lt;-channel），且不需要break。<br>具体执行逻辑如下：</p>
<ol>
<li>如果除default之外，只有一个case满足，则执行case内容</li>
<li>如果除default之外有多个case满足，则伪随机执行一个case内容</li>
<li>如果default之外的case都不满足，则执行default内容</li>
<li>如果没有default，所有case都不满足，则阻塞直到有一个case条件满足</li>
</ol>
<a id="more"></a>
<h2 id="select与channel使用demo"><a href="#select与channel使用demo" class="headerlink" title="select与channel使用demo"></a>select与channel使用demo</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">var</span> i1 <span class="keyword">string</span></span><br><span class="line">	s2 := <span class="string">"c2"</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		sec := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-time.After(<span class="number">1</span> * time.Second)</span><br><span class="line">			sec++</span><br><span class="line">			fmt.Printf(<span class="string">"========第%d秒========\n"</span>, sec)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-time.After(<span class="number">1050</span> * time.Millisecond)</span><br><span class="line">		c1 &lt;- <span class="string">"c1"</span></span><br><span class="line">		&lt;-time.After(<span class="number">1</span> * time.Second)</span><br><span class="line">		c3 &lt;- <span class="string">"c3"</span></span><br><span class="line">		&lt;-time.After(<span class="number">1</span> * time.Second)</span><br><span class="line">		c1 &lt;- <span class="string">"c1'"</span></span><br><span class="line"></span><br><span class="line">		&lt;-time.After(<span class="number">3</span> * time.Second)</span><br><span class="line">		fmt.Println(&lt;-c2)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">5</span></span><br><span class="line">		<span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			i--</span><br><span class="line">			timeout := time.After(<span class="number">2</span> * time.Second)</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">				fmt.Printf(<span class="string">"从c1收到%s\n"</span>, i1)</span><br><span class="line">			<span class="keyword">case</span> c2 &lt;- s2:</span><br><span class="line">				fmt.Printf(<span class="string">"发送%s到 c2\n"</span>, s2)</span><br><span class="line">			<span class="keyword">case</span> i3, ok := &lt;-c3:</span><br><span class="line">				<span class="keyword">if</span> ok &#123;</span><br><span class="line">					fmt.Printf(<span class="string">"从c3收到%s\n"</span>, i3)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					fmt.Printf(<span class="string">"c3 已关闭"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">				fmt.Println(<span class="string">"等待超时"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">8</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">"结束测试\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========第1秒=========</span><br><span class="line">从c1收到c1</span><br><span class="line">========第2秒=========</span><br><span class="line">从c3收到c3</span><br><span class="line">========第3秒=========</span><br><span class="line">从c1收到c1&apos;</span><br><span class="line">========第4秒=========</span><br><span class="line">========第5秒=========</span><br><span class="line">等待超时</span><br><span class="line">========第6秒=========</span><br><span class="line">c2</span><br><span class="line">发送c2到 c2</span><br><span class="line">========第7秒=========</span><br><span class="line">结束测试</span><br></pre></td></tr></table></figure>
<h2 id="通过done-channel退出goroutine"><a href="#通过done-channel退出goroutine" class="headerlink" title="通过done channel退出goroutine"></a>通过done channel退出goroutine</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 通知任务已完成</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(done)</span><br><span class="line">	<span class="comment">// 等待任务完成</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>Go语言并发模型：使用 select<br><a href="https://segmentfault.com/a/1190000006815341" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006815341</a></p>
<p>Go Channel 详解<br><a href="https://colobu.com/2016/04/14/Golang-Channels/" target="_blank" rel="noopener">https://colobu.com/2016/04/14/Golang-Channels/</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>使用@SerializableName注解自定义反序列化别名</title>
    <url>/2020/09/08/Java/%E4%BD%BF%E7%94%A8-SerializableName%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<p>主要用于“Java驼峰”和“小写+下划线”两种字段命名的自动化转换</p>
<a id="more"></a>
<p>在Java代码中，最常见的命名方式是驼峰。Http传输中，或者是Python之类脚本语言里，喜欢用“小写+下划线”来命名变量。<br>对于Gson来说，在Java里可以在字段上方添加“@SerializableName”注解直接指定需要序列化或者反序列化的字段名，例如“@SerializableName(“error_msg”)”。<br>对于Jackson来说，注解为“@JsonString(“error_msg”)”。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>goland远程调试go程序</title>
    <url>/2019/10/09/Go/goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95go%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>goland是基于intellij IDEA推出的开发go的IDE，所以很多之前Intellij的使用习惯可以保留下来，实属developer的福音，今天遇到一个新的问题，就是我要调试远程服务器上的go代码，远程系统是ubuntu或者centos，总之是没有图形界面的，我想在本地调试该怎么办呢，答案是使用Delve 这个专门的调试工具。</p>
<blockquote>
<p>前提：本地代码和远程代码保持一致，否则可能出现断点语句跟预期不一致或莫名其妙的情况。可以在Intellij中使用经典的remote host access插件来dowload或者upload代码实现同步。因为比较简单，具体使用姿势自行探索。</p>
</blockquote>
<a id="more"></a>
<h2 id="step1-远程主机"><a href="#step1-远程主机" class="headerlink" title="step1 远程主机"></a>step1 远程主机</h2><p>安装delve，项目地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fderekparker%2Fdelve" target="_blank" rel="noopener">https://github.com/derekparker/delve</a><br>按照官方的提示安装即可（注意因为GFW等你懂得的原因，网络下载可能较慢或不可用，请自行使用某高科技软件，如ss+proxychains等工具）。</p>
<p>下载并安装完成后输入dlv就会看到帮助信息：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10120431-bedad69d270e3ecf.png?imageMogr2/auto-orient/strip|imageView2/2/w/738/format/webp" alt="img"></p>
<p>image.png</p>
<h2 id="step2-本地"><a href="#step2-本地" class="headerlink" title="step2 本地"></a>step2 本地</h2><p>本地进入IDE，在要调试的地方打上断点，然后<br>run–debug–eidit configurations–&gt;添加remote主机信息。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10120431-3fce6c44c1aab4c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1125/format/webp" alt="img"></p>
<p>image.png</p>
<p>点debug 确认后，就会等待远端传回的debug信息。切远端：</p>
<h2 id="step3-远端"><a href="#step3-远端" class="headerlink" title="step3 远端"></a>step3 远端</h2><p>如我要对 main.go 这个项目debug，对main进行编译后，可以直接运行<br>dlv –listen=:2345 –headless=true –api-version=2 exec ./main<br>然后本地就收到了调试信息。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.jianshu.com/p/e74e940a64d9" target="_blank" rel="noopener">https://www.jianshu.com/p/e74e940a64d9</a> </p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Ceph块存储Demo</title>
    <url>/2019/04/19/K8S/Ceph%E5%9D%97%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>在Ceph支持的三种接口中，块存储（Librdb）是目前最稳定且达到生产环境要求的接口。本文将step by step向你演示如何将Rancher与Ceph-RBD块存储对接。</p>
<a id="more"></a>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a><strong>概要</strong></h2><h3 id="演示环境说明"><a href="#演示环境说明" class="headerlink" title="演示环境说明"></a><strong>演示环境说明</strong></h3><p>整个测试环境由以下2台本地虚拟机组成，相关信息说明如下：</p>
<p><img src="/images/1.png" alt></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>Librbd（RBD）是Ceph提供的块存储库，其利用Rados提供的API实现对卷的管理和操作。就目前而言，在Ceph支持的三种接口Posix(CephFS)、块存储(Librbd)和对象存储(RadosGW)接口中，块存储是目前最稳定且达到生产环境要求的接口。Ceph 块设备是精简配置的、大小可调且将数据条带化存储到集群内多个OSD 。Ceph 块设备利用 RADOS 的多种能力，如快照、复制和一致性。Ceph 的 RADOS 块设备（RBD）使用内核模块或 librbd 库与 OSD 交互。</p>
<h2 id="Rancher-RBD安装"><a href="#Rancher-RBD安装" class="headerlink" title="Rancher-RBD安装"></a><strong>Rancher-RBD安装</strong></h2><h3 id="Ceph-服务端安装"><a href="#Ceph-服务端安装" class="headerlink" title="Ceph 服务端安装"></a><strong>Ceph 服务端安装</strong></h3><p>如果没有Ceph 服务器，可以通过容器运行一个Ceph 服务器 DEMO环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=192.168.1.11 -e</span><br><span class="line">CEPH_PUBLIC_NETWORK=192.168.1.0/24 ceph/demo:tag-build-master-jewel-ubuntu-16.04</span><br></pre></td></tr></table></figure>
<p>IP地址根据实际情况修改。</p>
<p><strong>通过scp命令，把Ceph 服务容器所在宿主机/etc/ceph路径下所有文件复制到Rancher 环境下所有节点的相同路径下。</strong></p>
<h3 id="Ceph-RBD驱动插件安装"><a href="#Ceph-RBD驱动插件安装" class="headerlink" title="Ceph-RBD驱动插件安装"></a><strong>Ceph-RBD驱动插件安装</strong></h3><h4 id="添加自定义应用商店"><a href="#添加自定义应用商店" class="headerlink" title="添加自定义应用商店"></a><strong>添加自定义应用商店</strong></h4><p>进入 系统管理|系统设置 添加一个名为Ceph的自定义商店</p>
<p><img src="/images/2.png" alt></p>
<p>名称：Ceph<br>地址：<a href="https://github.com/niusmallnan/rancher-rbd-catalog.git" target="_blank" rel="noopener">https://github.com/niusmallnan/rancher-rbd-catalog.git</a><br>分支：master</p>
<h4 id="RBD驱动安装"><a href="#RBD驱动安装" class="headerlink" title="RBD驱动安装"></a><strong>RBD驱动安装</strong></h4><p>进入应用商店，搜索RBD进行安装。安装完成后：</p>
<p><img src="/images/3.png" alt></p>
<p>再进 系统架构|存储 查看，显示两个节点：</p>
<p><img src="/images/4.png" alt></p>
<h2 id="安装测试应用"><a href="#安装测试应用" class="headerlink" title="安装测试应用"></a><strong>安装测试应用</strong></h2><h3 id="应用安装"><a href="#应用安装" class="headerlink" title="应用安装"></a><strong>应用安装</strong></h3><p>新建一个名为myapp的空应用栈并添加myapp服务：</p>
<p><img src="/images/5.png" alt="](/images/5.png)"><img src="/images/6.png" alt="](/images/6.png)"></p>
<p><strong>红色线框为配置重点：</strong></p>
<p>使用驱动卷插件与使用本地卷驱动有所区别， 使用本地卷驱动添加卷时应该写 /AA/BB:/CC/DD,前后都要为路径； 使用驱动卷插件时应该写为 A:/BB/CC 。这个的A为一个卷名，不能是路径。</p>
<p>因为是Ceph存储，这里需要填卷驱动为：rancher-rbd 。部署好之后如图：</p>
<p><img src="/images/7.png" alt="](/images/7.png)"><img src="/images/8.png" alt="](/images/8.png)"></p>
<p>查看 基础架构|存储，容器卷卷名为:myapp</p>
<p><img src="/images/9.png" alt="](/images/9.png)"></p>
<h4 id="数据存储测试"><a href="#数据存储测试" class="headerlink" title="数据存储测试"></a><strong>数据存储测试</strong></h4><p>此时我们看到容器是运行在 :node1上，容器名为：myapp-myapp-1。</p>
<p><img src="/images/10.png" alt="](/images/10.png)"></p>
<p>通过执行命令登录容器，并向/root下写入test文件。</p>
<p><img src="/images/11.png" alt="](/images/11.png)"><img src="/images/12.png" alt="](/images/12.png)"></p>
<p>接着把这个服务容器删除，删除后myapp应用栈为空：</p>
<p><img src="/images/13.png" alt="](/images/13.png)"></p>
<p>在空应用栈中再添加一个服务，为了易于区分，重新命名为myapp2，并手动调度容器运行到node2上。</p>
<p>PS：新建的服务，参数中的卷名与卷映射路径必须相同，卷驱动也要相同。</p>
<p><img src="/images/14.png" alt="](/images/14.png)"><img src="/images/15.png" alt="](/images/15.png)"></p>
<p>点击创建，服务成功运行在node2上。</p>
<p><img src="/images/16.png" alt="](/images/16.png)"><img src="/images/17.png" alt="](/images/17.png)"></p>
<p>查看 基础架构|存储，容器卷卷名还为:myapp</p>
<p><img src="/images/18.png" alt="](/images/18.png)"></p>
<p>进入容器的/root目录查看创建的文件</p>
<p><img src="/images/19.png" alt="](/images/19.png)"></p>
<p>文件依然存在。此时容器是在node2上，说明文件并非保存在节点本地，证明Ceph存储对接成功。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www2.cnrancher.com/rancher-and-ceph-rbd/" target="_blank" rel="noopener">https://www2.cnrancher.com/rancher-and-ceph-rbd/</a> </p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
        <tag>块存储</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S重启Deployment的小技巧</title>
    <url>/2019/06/19/K8S/K8S%E9%87%8D%E5%90%AFDeployment%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>有时候我们会需要重启Deployment，原因可能是：</p>
<ol>
<li>docker image使用的是latest tag，这个latest在docker image registry已经更新了，我们需要重启deployment来使用新的latest</li>
<li>Pod运行缓慢但是还活着，我们就是想重启一下</li>
<li>ConfigMap/Secret变更了，想重启一下应用新配置</li>
</ol>
<p>上面两种情况的共同之处在于，Deployment spec没有发生任何变化，因此即使你<code>kubectl appply -f deployment-spec.yaml</code>也是没用的，因为K8S会认为你这个没有变化就什么都不做了。</p>
<p>但是我们又不想使用手工删除Pod-让K8S新建Pod的方式来重启Deployment，最好的办法应该是像<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">Updating a deployment</a>一样，让K8S自己滚动的删除-新建Pod。</p>
<p>有人对此给了一个<a href="https://github.com/kubernetes/kubernetes/issues/13488#issuecomment-356892053" target="_blank" rel="noopener">workaround</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch deployment &lt;deployment-name&gt; \</span><br><span class="line">  -p <span class="string">'&#123;"spec":&#123;"template":&#123;"spec":&#123;"containers":[&#123;"name":"&lt;container-name&gt;","env":[&#123;"name":"RESTART_","value":"'</span>$(date +%s)<span class="string">'"&#125;]&#125;]&#125;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<p>基本思路就是给Container添加一个无关紧要的环境变量，这个环境变量的值就是时间戳，而这个时间戳则是每次执行上述命令的系统当前时间。这样一来对于K8S来讲这个Deployment spec就变化了，就可以像<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment" target="_blank" rel="noopener">Updating a deployment</a>一样，重启Pod了。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://chanjarster.github.io/post/k8s-restart-deployment/" target="_blank" rel="noopener">https://chanjarster.github.io/post/k8s-restart-deployment/</a> </p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
  </entry>
  <entry>
    <title>Helm安装完之后遇到的权限问题</title>
    <url>/2019/04/18/K8S/Helm%E5%AE%89%E8%A3%85%E5%AE%8C%E4%B9%8B%E5%90%8E%E9%81%87%E5%88%B0%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>如果照著手冊使用 <code>helm init</code>安裝完 Helm 之後，使用 <code>helm list</code> 指令，會看到這樣的錯誤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ helm list</span><br><span class="line">Error: configmaps is forbidden: User &quot;system:serviceaccount:kube-system:default&quot; cannot list configmaps in the namespace &quot;kube-system&quot;: Unknown user &quot;system:serviceaccount:kube-system:default&quot;</span><br></pre></td></tr></table></figure>
<h4 id="首先，在helm-init前准备一个ServiceAccount"><a href="#首先，在helm-init前准备一个ServiceAccount" class="headerlink" title="首先，在helm init前准备一个ServiceAccount"></a>首先，在helm init前准备一个ServiceAccount</h4><p>setup-helm-rbac.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="number">2019</span><span class="number">-03</span><span class="string">-24T06:14:51Z</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tiller-token-bbvwm</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>角色：Role，拥有资源的权限，可以看做是一个职业</p>
<p>账号：ServiceAccount，用户使用K8S API的入口</p>
<p>当您（真人用户）访问集群（例如使用<code>kubectl</code>命令）时，<code>apiserver</code> 会将您认证为一个特定的 <code>User Account</code>（目前通常是<code>admin</code>，除非您的系统管理员自定义了集群配置）。<code>Pod</code> 容器中的进程也可以与 <code>apiserver</code> 联系。 当它们在联系 <code>apiserver</code> 的时候，它们会被认证为一个特定的 <code>Service Account</code>（例如default）。</p>
</blockquote>
<h4 id="刪除原本的-Tiller"><a href="#刪除原本的-Tiller" class="headerlink" title="刪除原本的 Tiller"></a>刪除原本的 Tiller</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl delete deployment tiller-deploy --namespace=kube-system</span><br><span class="line">$ kubectl delete svc tiller-deploy --namespace=kube-system</span><br></pre></td></tr></table></figure>
<h4 id="重新初始化-Helm-並且指定要使用的-Service-Account"><a href="#重新初始化-Helm-並且指定要使用的-Service-Account" class="headerlink" title="重新初始化 Helm 並且指定要使用的 Service Account"></a>重新初始化 Helm 並且指定要使用的 Service Account</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ helm init --service-account tiller</span><br></pre></td></tr></table></figure>
<h4 id="如果helm-init时没指定账号，也可以用以下命令补上"><a href="#如果helm-init时没指定账号，也可以用以下命令补上" class="headerlink" title="如果helm init时没指定账号，也可以用以下命令补上"></a>如果helm init时没指定账号，也可以用以下命令补上</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl patch deploy --namespace kube-system tiller-deploy -p &apos;&#123;&quot;spec&quot;:&#123;&quot;template&quot;:&#123;&quot;spec&quot;:&#123;&quot;serviceAccount&quot;:&quot;tiller&quot;&#125;&#125;&#125;&#125;&apos;</span><br></pre></td></tr></table></figure>
<h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h6><p>Helm 部署在 GKE 上的權限問題</p>
<p><a href="https://medium.com/smalltowntechblog/helm-tiller-%E9%83%A8%E7%BD%B2%E5%9C%A8-gke-%E4%B8%8A%E7%9A%84%E6%AC%8A%E9%99%90%E5%95%8F%E9%A1%8C-a016f703372e" target="_blank" rel="noopener">https://medium.com/smalltowntechblog/helm-tiller-%E9%83%A8%E7%BD%B2%E5%9C%A8-gke-%E4%B8%8A%E7%9A%84%E6%AC%8A%E9%99%90%E5%95%8F%E9%A1%8C-a016f703372e</a> </p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>Helm</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S 常用操作</title>
    <url>/2019/04/18/K8S/K8S-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>K8S</category>
      </categories>
  </entry>
  <entry>
    <title>Prometheus 相关</title>
    <url>/2019/09/23/K8S/Prometheus-%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>一本很好的gitbook</p>
<p><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="noopener">https://yunlzheng.gitbook.io/prometheus-book/</a> </p>
<a id="more"></a>
<p>CentOS 7 上面安装Prometheus</p>
<p><a href="https://www.howtoing.com/how-to-install-prometheus-and-node-exporter-on-centos-7" target="_blank" rel="noopener">https://www.howtoing.com/how-to-install-prometheus-and-node-exporter-on-centos-7</a> </p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>一些使用体会</p>
<p><a href="https://xenojoshua.com/2019/04/prometheus-note/" target="_blank" rel="noopener">https://xenojoshua.com/2019/04/prometheus-note/</a> </p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
  </entry>
  <entry>
    <title>Rancher 常用操作</title>
    <url>/2019/04/18/K8S/Rancher-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="Rancher中文文档"><a href="#Rancher中文文档" class="headerlink" title="Rancher中文文档"></a>Rancher中文文档</h4><p><a href="https://rancher.com/docs/rancher/latest/zh/" target="_blank" rel="noopener">https://rancher.com/docs/rancher/latest/zh/</a> </p>
<a id="more"></a>
<h3 id="Rancher重启"><a href="#Rancher重启" class="headerlink" title="Rancher重启"></a>Rancher重启</h3><p>对于某些节点的清扫，一般用到以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker stop `sudo docker ps -a|grep rancher|awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">sudo docker rm `sudo docker ps -a|grep rancher|awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">sudo docker volume rm $(sudo docker volume ls -qf dangling=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Rancher-server-使用外部数据库启动"><a href="#Rancher-server-使用外部数据库启动" class="headerlink" title="Rancher server 使用外部数据库启动"></a>Rancher server 使用外部数据库启动</h3><p>sudo docker run -d –restart=unless-stopped -p 8080:8080 rancher/server:v1.6.26 –db-host 外部库IP –db-port 3306 –db-user cattle –db-pass cattle –db-name cattle</p>
<h4 id="删除主机"><a href="#删除主机" class="headerlink" title="删除主机"></a>删除主机</h4><p>在 Rancher 内删除主机的操作需要进行几个步骤：从 <strong>基础架构</strong> 进入 <strong>主机</strong> 页面，点击需要删除的主机的下拉菜单，选择 <strong>停用</strong>。当主机完成停止以后，将会显示 <em>Inactive</em> 状态。然后点击下拉菜单，选择 <strong>删除</strong>，Rancher 会执行对这台主机的删除操作。当显示 <em>Removed</em> 状态时，就表示这台主机已经被删除了。但是，仍然可以在操作界面上看到这台主机，只有当点击下拉菜单，选择 <strong>清理</strong>后，这台主机才会从操作界面上消失。</p>
<p>如果这台主机是由 Rancher 调用 <code>docker-machine</code> 基于云提供商的驱动创建，按照上述的删除操作执行后，被删除的主机也会在云提供商的管理界面中消失。但是，如果是采用 <a href="https://rancher.com/docs/rancher/v1.6/zh/hosts/custom/" target="_blank" rel="noopener">添加自定义主机</a> 的方式所添加的云提供商主机，被删除的主机还会在云提供商的管理界面中被查看到。而且这台主机内的容器服务（例如 <code>rancher/agent</code>）还是保留着的。可以认为通过自定义添加的云提供商的主机被删除后，只是从Rancher的调度中解离出去，但是它原来的生命周期Rancher不会干涉。</p>
<blockquote>
<p><strong>注意：</strong>对自定义主机，包括Rancher Agent在内的全部容器都会保留在该主机上。同时，Rancher网络驱动创建的<code>docker0</code>上的IP也将会保留。</p>
</blockquote>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>Rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>在容器中获取podIP</title>
    <url>/2019/09/18/K8S/%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%8E%B7%E5%8F%96podIP/</url>
    <content><![CDATA[<p>通过环境变量来实现，该环境变量直接引用 resource 的状态字段，示例如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: world-v2</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    app: world-v2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: world-v2</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: service</span><br><span class="line">        image: test</span><br><span class="line">        env:</span><br><span class="line">        - name: POD_IP</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: status.podIP</span><br><span class="line">        ports:</span><br><span class="line">        - name: service</span><br><span class="line">          containerPort: 777</span><br></pre></td></tr></table></figure>
<p>容器中可以直接使用 <code>POD_IP</code> 环境变量获取容器的 IP。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="http://www.bookoco.com/read/kubernetes/appendix-tricks.md" target="_blank" rel="noopener">http://www.bookoco.com/read/kubernetes/appendix-tricks.md</a> </p>
<p>同时，这也是一本很好的K8S指南</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
  </entry>
  <entry>
    <title>下载指定版本kubectl</title>
    <url>/2019/04/18/K8S/%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACkubectl/</url>
    <content><![CDATA[ <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.11.9/bin/linux/amd64/kubectl</span><br></pre></td></tr></table></figure>
<p><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl</a> </p>
<a id="more"></a>]]></content>
      <categories>
        <category>K8S</category>
      </categories>
  </entry>
  <entry>
    <title>强制删除StatefulSets的pod</title>
    <url>/2019/04/18/K8S/%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4StatefulSets%E7%9A%84pod/</url>
    <content><![CDATA[<p>本文档说明了如何删除StatefulSet中的Pod，并解释了在删除操作时需要牢记的注意事项。</p>
<ul>
<li>Before you begin</li>
<li>有关StatefulSet的注意事项</li>
<li>删除Pod<ul>
<li>强制删除</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="Before-you-begin"><a href="#Before-you-begin" class="headerlink" title="Before you begin"></a>Before you begin</h2><ul>
<li>本任务相对高阶，包含一些可能违背StatefulSet固有属性或者常规规则的内容。</li>
<li>在阅读前，请您先熟悉以下列出的注意事项。</li>
</ul>
<h2 id="有关StatefulSet的注意事项"><a href="#有关StatefulSet的注意事项" class="headerlink" title="有关StatefulSet的注意事项"></a>有关StatefulSet的注意事项</h2><p>在正常的StatefulSet操作中，<strong>从不</strong>需要强制删除StatefulSet中的Pod。StatefulSet控制器（StatefulSet Controller）负责创建、伸缩和删除StatefulSet中的所有成员。控制器将确保序号从0到N-1的Pod处于活跃健康的状态，而StatefulSet保证了在任何时候，集群中至多有一个拥有给定ID的Pod存在。这一特性被称为StatefulSet的<em>至多一个</em>原则。</p>
<p>手动强制删除应谨慎进行，因为这种操作导致的结果可能违背了StatefulSet所固有的至多一个原则。StatefulSet可被用于运行需要稳定网络关联关系和稳定持久化存储的集群化或分布式应用程序。通常，这些应用程序的配置需要依赖一个拥有固定成员数量的集群，而这些集群成员自己也需要拥有固定ID从而能够在集群中识别它们。如果多个集群中的成员使用相同的ID可能引发灾难性的后果并可能导致数据丢失（例如在基于法定数量的系统中出现分片等情况）。</p>
<h2 id="删除Pod"><a href="#删除Pod" class="headerlink" title="删除Pod"></a>删除Pod</h2><p>以下命令可以优雅地删除Pod（graceful delete）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete pods &lt;pod&gt;</span><br></pre></td></tr></table></figure>
<p>为了能够顺利使用上述命令终止Pod，Pod的属性<code>pod.Spec.TerminationGracePeriodSeconds</code><strong>不能</strong>被设置为0。设置<code>pod.Spec.TerminationGracePeriodSeconds</code>为0的做法对于StatefulSet的Pod来讲是不安全的，强烈不推荐使用。上述Graceful Delete的方式是安全的，并可保证在kubelet删除apiserver上的数据之前<a href="https://k8smeetup.github.io/docs/user-guide/pods/#termination-of-pods" target="_blank" rel="noopener">Pod被顺利终止</a>。</p>
<p>Kubernetes(1.5或者更高版本)不会因为集群节点不可达（unreachable node）而删除Pod。在不可达节点上运行的Pod在<a href="https://k8smeetup.github.io/docs/admin/node/#node-condition" target="_blank" rel="noopener">超时</a>后将进入’Terminating’或者’Unknown’状态。如果用户尝试使用Graceful Delete删除不可达节点上的Pod时，Pod可能进入这些状态。以下列举了可以从apiserver上删除处于这些状态的Pod的方法：</p>
<ul>
<li>删除节点对象（可以由您删除，也可以由<a href="https://k8smeetup.github.io/docs/admin/node" target="_blank" rel="noopener">节点控制器(Node Controller)</a>删除）。</li>
<li>不可达节点上的kubelet开始响应，终止了Pod并从apiserver上删除了相关数据条目。</li>
<li>用户强制删除Pod。</li>
</ul>
<p>推荐的最佳做法是使用上述第一或者第二种方法。如果节点被确认为死机（例如永久断开网络连接，掉电等），则删除节点对象。如果有网络分片发生，则应先解决分片问题或者等待分片问题解决。网络分片问题解决后，kubelet将完成对Pod的删除并删除apiserver上的相关数据。</p>
<p>通常而言，一旦Pod不再在节点上运行或者节点被管理员删除，系统将会完成删除操作。您也可以通过强制删除来完成删除操作。</p>
<h3 id="强制删除"><a href="#强制删除" class="headerlink" title="强制删除"></a>强制删除</h3><p>强制删除<strong>并不</strong>等待kubelet确认待删除的Pod已经终止。无论是否成功终止了Pod，强制删除都会立即删除apiserver上的相关对象和数据。这会让StatefulSet控制器创建一个具有相同ID的Pod来替代被删除的Pod。这一过程可能导致具有重复ID的Pod同时出现在集群中，而此时被删除的Pod如果仍能与StatefulSet中的其他成员通信的话，则违背了StatefulSet所维护的至多一个原则。</p>
<p>在您强制删除StatefulSet中的Pod时，请务必确认待删除的Pod将永不与StatefulSet中的其他Pod通信并且其数据可以安全地从apiserver中删除从而能让StatefulSet控制器创建一个新的Pod来替换待删除的Pod。</p>
<p>若使用1.5或者更高版本的kubectl强制删除Pod，请执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete pods &lt;pod&gt; --grace-period=0 --force</span><br></pre></td></tr></table></figure>
<p>如果您使用1.4或者更低版本的kubectl，需要省略<code>--force</code>选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete pods &lt;pod&gt; --grace-period=0</span><br></pre></td></tr></table></figure>
<p>在强制删除StatefulSet的Pod前，请务必充分了解这一操作所带来的各种风险。</p>
<p>## </p>
<h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h6><p><a href="https://k8smeetup.github.io/docs/tasks/run-application/force-delete-stateful-set-pod/" target="_blank" rel="noopener">https://k8smeetup.github.io/docs/tasks/run-application/force-delete-stateful-set-pod/</a> </p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS 7 Shadowsocks+Privoxy 代理</title>
    <url>/2019/04/20/Linux/CentOS-7-Shadowsocks-Privoxy-%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>“本文介绍的是在 CentOS 上安装 shadowsocks 客户端的过程，最终实现的也就是当前 CentOS 通过其他服务器的 Shadowsocks 服务联网，非在 CentOS 上安装 shadowsocks 服务端的过程，因此你需要一个已经能科学上网的 shadowsocks 服务端。”</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍的是在 CentOS 上安装 shadowsocks 客户端的过程，最终实现的也就是当前 CentOS 通过其他服务器的 Shadowsocks 服务联网，非在 CentOS 上安装 shadowsocks 服务端的过程，因此你需要一个已经能科学上网的 shadowsocks 服务端。</p>
<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p>Pip 是 Python 的包管理工具，这里我们用 pip 安装 shadowsocks。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>
<h2 id="配置-shadowsocks"><a href="#配置-shadowsocks" class="headerlink" title="配置 shadowsocks"></a>配置 shadowsocks</h2><p>新建配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>
<p>填写以下内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;your_server_ip&quot;,      #ss服务器IP</span><br><span class="line">    &quot;server_port&quot;:your_server_port, #端口</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,   #本地ip</span><br><span class="line">    &quot;local_port&quot;:1080,              #本地端口</span><br><span class="line">    &quot;password&quot;:&quot;your_server_passwd&quot;,#连接ss密码</span><br><span class="line">    &quot;timeout&quot;:300,                  #等待超时</span><br><span class="line">    &quot;method&quot;:&quot;rc4-md5&quot;,             #加密方式</span><br><span class="line">    &quot;fast_open&quot;: false,             # true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可</span><br><span class="line">    &quot;workers&quot;: 1                    # 工作线程数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo参考：</p>
<p>服务器地址：45.76.93.4 服务器端口：16458 加密方式：chacha20 密码：ZwtU9c 协议：origin 协议参数： 混淆：plain 混淆参数： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;23.105.222.129&quot;,</span><br><span class="line">    &quot;server_port&quot;:5800,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;*******&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false,</span><br><span class="line">    &quot;workers&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动shadowsocks服务"><a href="#启动shadowsocks服务" class="headerlink" title="启动shadowsocks服务"></a>启动shadowsocks服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>
<h2 id="设置shadowsocks开机自启"><a href="#设置shadowsocks开机自启" class="headerlink" title="设置shadowsocks开机自启"></a>设置shadowsocks开机自启</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/shadowsocks.service</span><br></pre></td></tr></table></figure>
<p>填写如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Client Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/bin/sslocal -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>配置生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable /etc/systemd/system/shadowsocks.service</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行<code>curl --socks5 127.0.0.1:1080 http://httpbin.org/ip</code><br>如果返回你的 ss 服务器 ip 则测试成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;origin&quot;: &quot;23.105.222.129&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安装-Privoxy"><a href="#安装-Privoxy" class="headerlink" title="安装 Privoxy"></a>安装 Privoxy</h2><p>Shadowsocks 是一个 socket5 服务，因此我们需要使用 Privoxy 把流量转到 http/https 上。<br>直接使用yum安装即可：<br><code>yum install privoxy</code><br>安装好后，修改一下配置：<br><code>vim /etc/privoxy/config</code><br>搜索<code>forward-socks5t</code>将<br><code>forward-socks5t / 127.0.0.1:9050 .</code><br>取消注释并修改为：<br><code>forward-socks5t / 127.0.0.1:1080 .</code></p>
<h2 id="启动-privoxy"><a href="#启动-privoxy" class="headerlink" title="启动 privoxy"></a>启动 privoxy</h2><p><code>privoxy /etc/privoxy/config</code><br>或以指定用户如www运行privoxy：<br><code>privoxy --user www /etc/privoxy/config</code></p>
<h2 id="设置privoxy开机自启"><a href="#设置privoxy开机自启" class="headerlink" title="设置privoxy开机自启"></a>设置privoxy开机自启</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/privoxy.service</span><br></pre></td></tr></table></figure>
<p>填写如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Privoxy Web Proxy With Advanced Filtering Capabilities</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/privoxy.pid</span><br><span class="line">ExecStart=/usr/sbin/privoxy --pidfile /run/privoxy.pid /etc/privoxy/config</span><br></pre></td></tr></table></figure>
<p>配置生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable /lib/systemd/system/privoxy.service</span><br></pre></td></tr></table></figure>
<h2 id="配置-etc-profile"><a href="#配置-etc-profile" class="headerlink" title="配置/etc/profile"></a>配置/etc/profile</h2><p>执行<code>vim /etc/profile</code>,添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:8118</span><br><span class="line">export https_proxy=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure>
<p>修改后使配置生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>测试生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure>
<p>返回一大堆 HTML 则说明 shadowsocks 正常工作了。<br>备注：如果不需要用代理了，把 /etc/profile 里的配置注释即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 设置是否显示行号</title>
    <url>/2019/04/17/Linux/Vim%20%E8%AE%BE%E7%BD%AE%E6%98%AF%E5%90%A6%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7/</url>
    <content><![CDATA[<p>Vim添加行号有助于定位文件内容，但是复制内容时会把行号也复制进去。找到了切换是否显示行号的方法</p>
<a id="more"></a>
<h4 id="不显示行号"><a href="#不显示行号" class="headerlink" title="不显示行号"></a>不显示行号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set nonumber</span><br></pre></td></tr></table></figure>
<h4 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set number</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>研发效能</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 安装Golang 1.9以上版本</title>
    <url>/2019/04/20/Linux/Centos-%E5%AE%89%E8%A3%85Golang-1-9%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>Centos执行yum install golang，安装的go版本为1.8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># go version</span><br><span class="line">go version go1.8.3 linux/amd64</span><br></pre></td></tr></table></figure>
<p>如果已经yum安装了go，可以通过下面的命令删掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/bin/go</span><br><span class="line">rm -rf /etc/alternatives/go</span><br><span class="line">rm -rf /usr/lib/golang</span><br></pre></td></tr></table></figure>
<p>如果想要安装1.9以上版本，得先下载官方提供的tar包，如下：</p>
<p><a href="https://storage.googleapis.com/golang/go1.9.4.linux-amd64.tar.gz" target="_blank" rel="noopener">https://storage.googleapis.com/golang/go1.9.4.linux-amd64.tar.gz</a></p>
<p>可以在<code>golang.org/dl</code>查询可用的go版本</p>
<p>将tar包传到Centos上，之后操作命令参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar -C /root -xzf go1.9.4.linux-amd64.tar.gz</span><br><span class="line"># cd /root; vi ~/.bashrc</span><br><span class="line">export GOPATH=/root/Go</span><br><span class="line">export GOROOT=/root/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line"># source ~/.bashrc</span><br><span class="line"># go version</span><br><span class="line">go version go1.9.4 linux/amd64</span><br></pre></td></tr></table></figure>
<a id="more"></a>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Windows换行符导致shell脚本在Linux无法运行</title>
    <url>/2019/04/20/Linux/Windows%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%AF%BC%E8%87%B4shell%E8%84%9A%E6%9C%AC%E5%9C%A8Linux%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>$’\r’: command not found错误</p>
<p>打开vi使用<code>set ff=unix</code>解决这个换行符的问题后，重新启动问题解决 </p>
<a id="more"></a>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 常用操作</title>
    <url>/2019/04/18/Linux/Linux-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="CentOS查看防火墙状态"><a href="#CentOS查看防火墙状态" class="headerlink" title="CentOS查看防火墙状态"></a>CentOS查看防火墙状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>
<p>停止firewall</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service1</span><br></pre></td></tr></table></figure>
<p>禁止firewall开机启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>
<h4 id="安装-netstat-命令"><a href="#安装-netstat-命令" class="headerlink" title="安装 netstat 命令"></a>安装 netstat 命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install net-tools</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux下环境变量PATH设置错误的补救</title>
    <url>/2019/07/13/Linux/linux%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FPATH%E8%AE%BE%E7%BD%AE%E9%94%99%E8%AF%AF%E7%9A%84%E8%A1%A5%E6%95%91/</url>
    <content><![CDATA[<pre><code>&quot;export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin&quot;
</code></pre><a id="more"></a>
<p>修复PATH变量其实很简单，就是重新给PATH变量赋值就可以了。至于PATH的默认值可以从其他的服务器上复制过来。<br>使用”echo $PATH”命令就可以查看当前服务器的PATH变量值，在正常的服务器上运行命令并复制输出的结果，然后用”export PATH”命令重新给PATH命令赋值就可以了。命令如下：</p>
<pre><code>&quot;export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin&quot;
</code></pre><hr>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>作者：铭霏<br>来源：CSDN </p>
<p>原文：<a href="https://blog.csdn.net/u012102306/article/details/51036561" target="_blank" rel="noopener">https://blog.csdn.net/u012102306/article/details/51036561</a> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>chown、chmod改变文件权限</title>
    <url>/2019/05/04/Linux/chown%E3%80%81chmod%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>chgrp ：改变文件所属群组<br>chown ：改变文件拥有者<br>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性</p>
<p>常用权限数字：</p>
<blockquote>
<p>vim编辑后 -rw-rw-r– : 664<br>修改为可执行文件 -rwxr-xr-x : 755<br>禁止其他用户查看 -rwxr----- : 740</p>
</blockquote>
<a id="more"></a>
<h2 id="改变所属群组-chgrp"><a href="#改变所属群组-chgrp" class="headerlink" title="改变所属群组, chgrp"></a>改变所属群组, chgrp</h2><p>改变一个文件的群组真是很简单的，直接以chgrp来改变即可，咦！这个指令就是change group的缩写嘛！这样就很好记了吧！ ^_^。不过，请记得，要被改变的组名必须要在/etc/group文件内存在才行，否则就会显示错误！</p>
<p>假设你是以root的身份登入Linux系统的，那么在你的家目录内有一个install.log的文件， 如何将该文件的群组改变一下呢？假设你已经知道在/etc/group里面已经存在一个名为users的群组， 但是testing这个群组名字就不存在/etc/group当中了，此时改变群组成为users与testing分别会有什么现象发生呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chgrp [-R] dirname/filename ...</span></span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件、目录</span><br><span class="line">     都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。</span><br><span class="line">范例：</span><br><span class="line">[root@www ~]<span class="comment"># chgrp users install.log</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--  1 root users 68495 Jun 25 08:53 install.log</span><br><span class="line">[root@www ~]<span class="comment"># chgrp testing install.log</span></span><br><span class="line">chgrp: invalid group name `testing<span class="string">' &lt;== 发生错误讯息啰～找不到这个群组名～</span></span><br></pre></td></tr></table></figure>
<p>发现了吗？文件的群组被改成users了，但是要改成testing的时候， 就会发生错误～注意喔！发生错误讯息还是要努力的查一查错误讯息的内容才好！ 将他英文翻译成为中文，就知道问题出在哪里了。</p>
<h2 id="改变文件拥有者-chown"><a href="#改变文件拥有者-chown" class="headerlink" title="改变文件拥有者, chown"></a>改变文件拥有者, chown</h2><p>如何改变一个文件的拥有者呢？很简单呀！既然改变群组是change group，那么改变拥有者就是change owner啰！BINGO！那就是chown这个指令的用途，要注意的是， 用户必须是已经存在系统中的账号，也就是在/etc/passwd 这个文件中有纪录的用户名称才能改变。</p>
<p>chown的用途还满多的，他还可以顺便直接修改群组的名称呢！此外，如果要连目录下的所有次目录或文件同时更改文件拥有者的话，直接加上 -R 的选项即可！我们来看看语法与范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chown [-R] 账号名称 文件或目录</span></span><br><span class="line">[root@www ~]<span class="comment"># chown [-R] 账号名称:组名 文件或目录</span></span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都变更</span><br><span class="line">范例：将install.log的拥有者改为bin这个账号：</span><br><span class="line">[root@www ~]<span class="comment"># chown bin install.log</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</span><br><span class="line">范例：将install.log的拥有者与群组改回为root：</span><br><span class="line">[root@www ~]<span class="comment"># chown root:root install.log</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</span><br></pre></td></tr></table></figure>
<p>Tips:</p>
<blockquote>
<p>事实上，chown也可以使用『chown user.group file』，亦即在拥有者与群组间加上小数点『.』也行！ 不过很多朋友设定账号时，喜欢在账号当中加入小数点(例如vbird.tsai这样的账号格式)，这就会造成系统的误判了！ 所以我们比较建议使用冒号『:』来隔开拥有者与群组啦！此外，chown也能单纯的修改所属群组呢！ 例如『chown .sshd install.log』就是修改群组～看到了吗？就是那个小数点的用途！</p>
</blockquote>
<p>知道如何改变文件的群组与拥有者了，那么什么时候要使用chown或chgrp呢？或许你会觉得奇怪吧？ 是的，确实有时候需要变更文件的拥有者的，最常见的例子就是在复制文件给你之外的其他人时， 我们使用最简单的cp指令来说明好了：</p>
<p><code>[root@www ~]# cp 来源文件 目标文件</code><br>假设你今天要将.bashrc这个文件拷贝成为.bashrc_test档名，且是要给bin这个人，你可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># cp .bashrc .bashrc_test</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc*</span></span><br><span class="line">-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc</span><br><span class="line">-rw-r--r--  1 root root 395 Jul 13 11:31 .bashrc_test  &lt;==新文件的属性没变</span><br></pre></td></tr></table></figure>
<p>由于复制行为(cp)会复制执行者的属性与权限，所以！怎么办？.bashrc_test还是属于root所拥有， 如此一来，即使你将文件拿给bin这个使用者了，那他仍然无法修改的(看属性/权限就知道了吧)， 所以你就必须要将这个文件的拥有者与群组修改一下啰！知道如何修改了吧？</p>
<h2 id="改变权限-chmod"><a href="#改变权限-chmod" class="headerlink" title="改变权限, chmod"></a>改变权限, chmod</h2><p>文件权限的改变使用的是chmod这个指令，但是，权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。我们就来谈一谈：</p>
<h3 id="数字类型改变文件权限"><a href="#数字类型改变文件权限" class="headerlink" title="数字类型改变文件权限"></a>数字类型改变文件权限</h3><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限， 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<blockquote>
<p>r:4<br>w:2<br>x:1</p>
</blockquote>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：</p>
<blockquote>
<p>owner = rwx = 4+2+1 = 7<br>group = rwx = 4+2+1 = 7<br>others= — = 0+0+0 = 0</p>
</blockquote>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chmod [-R] xyz 文件或目录</span></span><br><span class="line">选项与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</span><br><span class="line">-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</span><br></pre></td></tr></table></figure>
<p>举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么就下达： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc</span><br><span class="line">[root@www ~]<span class="comment"># chmod 777 .bashrc</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</span><br></pre></td></tr></table></figure>
<p>那如果要将权限变成『 -rwxr-xr– 』呢？那么权限的分数就成为 [ 4+2+1 ]  [ 4+0+1 ] [ 4+0+0 ] = 754 啰！所以你需要下达『 chmod 754 filename』。 另外，在实际的系统运作中最常发生的一个问题就是，常常我们以vim编辑一个shell的文字批处理文件后，他的权限通常是 -rw-rw-r– 也就是664， 如果要将该文件变成可执行文件，并且不要让其他人修改此一文件的话， 那么就需要-rwxr-xr-x这样的权限，此时就得要下达：『 chmod 755 test.sh 』的指令啰！</p>
<p>另外，如果有些文件你不希望被其他人看到，那么应该将文件的权限设定为例如：『-rwxr—–』，那就下达『 chmod 740 filename 』吧！ </p>
<h3 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h3><p>还有一个改变权限的方法呦！从之前的介绍中我们可以发现，基本上就九个权限分别是(1)user (2)group (3)others三种身份啦！那么我们就可以藉由u, g, o来代表三种身份的权限！此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x！也就是可以使用底下的方式来看：</p>
<p><code>chmod       &lt;u/g/o/a&gt;       &lt;+(加入)/-(除去)/=(设定)&gt;       &lt;r/w/x&gt;    文件或目录</code></p>
<p>来实作一下吧！假如我们要『设定』一个文件的权限成为『-rwxr-xr-x』时，基本上就是：</p>
<p>user (u)：具有可读、可写、可执行的权限；<br>group 与 others (g/o)：具有可读与执行的权限。</p>
<p>所以就是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chmod  u=rwx,go=rx  .bashrc</span></span><br><span class="line"><span class="comment"># 注意喔！那个 u=rwx,go=rx 是连在一起的，中间并没有任何空格！</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x  1 root root 395 Jul  4 11:45 .bashrc</span><br></pre></td></tr></table></figure>
<p>那么假如是『 -rwxr-xr– 』这样的权限呢？可以使用『 chmod u=rwx,g=rx,o=r filename 』来设定。此外，如果我不知道原先的文件属性，而我只想要增加.bashrc这个文件的每个人均可写入的权限， 那么我就可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x  1 root root 395 Jul  4 11:45 .bashrc</span><br><span class="line">[root@www ~]<span class="comment"># chmod  a+w  .bashrc</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</span><br></pre></td></tr></table></figure>
<p>而如果是要将权限去掉而不更动其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># chmod  a-x  .bashrc</span></span><br><span class="line">[root@www ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rw-rw-rw-  1 root root 395 Jul  4 11:45 .bashrc</span><br></pre></td></tr></table></figure>
<p>知道 +, -, = 的不同点了吗？对啦！ + 与 – 的状态下，只要是没有指定到的项目，则该权限『不会被变动』， 例如上面的例子中，由于仅以 – 拿掉 x 则其他两个保持当时的值不变！多多实作一下，你就会知道如何改变权限啰！ 这在某些情况底下很好用的～举例来说，你想要教一个朋友如何让一个程序可以拥有执行的权限， 但你又不知道该文件原本的权限为何，此时，利用『chmod a+x filename』 ，就可以让该程序拥有执行的权限了。是否很方便？</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>鸟哥的私房菜</p>
<p><a href="http://cn.linux.vbird.org/linux_basic/0210filepermission.php#filepermission_ch" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_basic/0210filepermission.php#filepermission_ch</a> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>vim 替换字符串</title>
    <url>/2019/09/18/Linux/vim-%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p> 　　:1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1 </p>
<a id="more"></a>
<h1 id="vim字符串替换及小技巧"><a href="#vim字符串替换及小技巧" class="headerlink" title="vim字符串替换及小技巧"></a>vim字符串替换及小技巧</h1><p>原文：<a href="http://blog.csdn.net/nitweihong/article/details/7221930" target="_blank" rel="noopener">http://blog.csdn.net/nitweihong/article/details/7221930</a></p>
<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>vi/vim 中可以使用 :s 命令来替换字符串。以前只会使用一种格式来全文替换，今天发现该命令有很多种写法(vi 真是强大啊，还有很多需要学习)，记录几种在此，方便以后查询。</p>
<p>　　:s/vivian/sky/ 替换当前行第一个 vivian 为 sky</p>
<p>　　:s/vivian/sky/g 替换当前行所有 vivian 为 sky</p>
<p>　　:n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky</p>
<p>　　:n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky</p>
<p>　　n 为数字，若 n 为 .，表示从当前行开始到最后一行</p>
<p>　　:%s/vivian/sky/(等同于 :g/vivian/s//sky/) 替换每一行的第一个 vivian 为 sky</p>
<p>　　:%s/vivian/sky/g(等同于 :g/vivian/s//sky/g) 替换每一行中所有 vivian 为 sky</p>
<p>　　可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符</p>
<p>　　:s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/</p>
<p>　　:%s+/oradata/apras/+/user01/apras1+ (使用+ 来 替换 / )： /oradata/apras/替换成/user01/apras1/</p>
<p>　　* <strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>　　1.:s/vivian/sky/ 替换当前行第一个 vivian 为 sky</p>
<p>　　:s/vivian/sky/g 替换当前行所有 vivian 为 sky</p>
<p>　　2. :n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky</p>
<p>　　:n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky</p>
<p>　　(n 为数字，若 n 为 .，表示从当前行开始到最后一行)</p>
<p>　　3. :%s/vivian/sky/(等同于 :g/vivian/s//sky/) 替换每一行的第一个 vivian 为 sky</p>
<p>　　:%s/vivian/sky/g(等同于 :g/vivian/s//sky/g) 替换每一行中所有 vivian 为 sky</p>
<p>　　4. 可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符</p>
<p>　　:s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/</p>
<p>　　5. 删除文本中的^M</p>
<p>　　问题描述：对于换行,window下用回车换行(0A0D)来表示，linux下是回车(0A)来表示。这样，将window上的文件拷到unix上用时，总会有个^M.请写个用在unix下的过滤windows文件的换行符(0D)的shell或c程序。</p>
<p>　　· 使用命令：cat filename1 | tr -d “VM” &gt;newfile;</p>
<p>　　· 使用命令：sed -e “s/VM//” filename &gt;outputfilename。需要注意的是在1、2两种方法中，V和M指的是Ctrl+V和Ctrl+M。你必须要手工进行输入，而不是粘贴。</p>
<p>　　· 在vi中处理：首先使用vi打开文件，然后按ESC键，接着输入命令：%s/VM//。</p>
<p>　　· :%s/^M$//g</p>
<p>　　如果上述方法无用，则正确的解决办法是：</p>
<p>　　· tr -d “r” <src>dest</src></p>
<p>　　· tr -d “5” dest</p>
<p>　　· strings A&gt;B</p>
<p>　　6. 其它</p>
<p>　　利用 :s 命令可以实现字符串的替换。具体的用法包括：</p>
<p>　　:s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1</p>
<p>　　:s/str1/str2/g 用字符串 str2 替换行中所有出现的字符串 str1</p>
<p>　　:.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1</p>
<p>　　:1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1</p>
<p>　　:g/str1/s//str2/g 功能同上</p>
<p>　　从上述替换命令可以看到：g 放在命令末尾，表示对搜索字符串的每次出现进行替换;不加 g，表示只对搜索</p>
<p>　　字符串的首次出现进行替换;g 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作。</p>
<p>前几天我记录一下如何在vim中替换文字。只是很简单的给出了两个命令。其实还只是初级功能，今天来看看稍微复杂一点的。 用:%s/from/to 命令只替换每行的第一个匹配字符，如果要替换每行的所有匹配项，需要在后面加上g命令。如： :%s/from/to/g</p>
<p>另外，我们往往在替换的时候需要很小心，不能够这样就全部替换了，需要我们一个个的确认，那么我们可以加上c命令，意思就是confirm。如： :%s/from/to/gc 输入这个命令之后，vim会把所有匹配的文字高亮，并会询问你 <code>replace with to (y/n/a/q/l/^E/^Y)</code> ,输入y表示替换当前这个，n表示这个不要替换，a表示全部替换，q表示退出，不替换了，l表示把当前这个替换后就退出，<code>^E</code>(ctrl+e,好像大小写都可以)表示向下滚动一行，<code>^Y</code>表示向上滚动一行.</p>
<p>上次我们说了可以在s前面加上范围,比如:1,5s/from/to表示替换1到5行的from,在vim中有些字符可以很方便的表示一些特殊行,比如.表示当前行,<code>\(</code>表示最后一行,第一行当然就是1了.所以我们可以用:.s/from/to命令替换当前行的from,用:.,)s/from/to替换从当前行到结束行的每行的第一个匹配的from.</p>
<p>好了现在对于vim的文字替换功能有了更一步的了解了.其实这样的替换还是最简单的,并且很容易出错,因为它并不会断词,会把fromxxx也当成匹配项,这当然是错误的,我们可以加上\&lt;来表示匹配一个单词的开始,>来表示单词的结束, 命令看起来就像这个样子:%s/\&lt;from>/to/g</p>
<p><code>:%s/\r//g</code> 清除那个^M</p>
<p>linux使用grep或者vim删除空行</p>
<p><code>grep -v ^$ oldfile &gt; newfile</code> 但是似乎在FreeBSD下面不行，会不会是grep版本的问题? 后来想到了很刁的vim的全局替换，最后成功</p>
<p>vim的命令为：<code>%s/^\n//g</code> 意思是全局替换所有以回车开头的字符，替换为空。</p>
<p>顺便研究了一下 如果有多个连续的空行，想保留一个 vim的命令为：%s/^\n$//g</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="http://xstarcd.github.io/wiki/vim/vim_replace_encodeing.html" target="_blank" rel="noopener">http://xstarcd.github.io/wiki/vim/vim_replace_encodeing.html</a> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>研发效能</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>在CentOS上配置MySQL</title>
    <url>/2019/04/20/Linux/%E5%9C%A8CentOS%E4%B8%8A%E9%85%8D%E7%BD%AEMySQL/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd mysql</span><br><span class="line">sudo useradd -r -g mysql -s /bin/<span class="literal">false</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># Postinstallation setup</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">sudo mkdir mysql-files</span><br><span class="line">sudo chown mysql:mysql mysql-files</span><br><span class="line">sudo chmod 777 mysql-files</span><br><span class="line">sudo bin/mysqld --initialize --user=mysql</span><br><span class="line">  </span><br><span class="line">sudo mkdir /var/run/mariadb</span><br><span class="line">sudo mkdir /var/<span class="built_in">log</span>/mariadb</span><br><span class="line">sudo chown mysql:mysql</span><br><span class="line">sudo touch /var/<span class="built_in">log</span>/mariadb/mariadb.log</span><br><span class="line">sudo chmod 777 /var/<span class="built_in">log</span>/mariadb/mariadb.log</span><br><span class="line">sudo chmod 777 /var/run/mariadb/</span><br><span class="line">sudo chmod 777 /var/<span class="built_in">log</span>/mariadb/</span><br><span class="line">sudo chmod 777 /var/lib/mysql</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sudo bin/mysql_ssl_rsa_setup             </span><br><span class="line">sudo bin/mysqld_safe --user=mysql &amp;</span><br><span class="line">sudo bin/mysqld --user=mysql &amp;</span><br><span class="line">sudo vim ~/.bash_profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line"> </span><br><span class="line">如果mysqld_safe遇到错误</span><br><span class="line">mysqld_safe mysqld from pid file /var/lib/mysql/mysqld.pid ended</span><br><span class="line">sudo chmod 777 /var/<span class="built_in">log</span>/mariadb/mariadb.log</span><br><span class="line">chmod -R 777 /var/lib/mysql   <span class="comment">#这个是重点</span></span><br><span class="line">如果在mysql -uroot -p 登录时，提示：</span><br><span class="line">ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/tmp/mysql.sock<span class="string">' (2)</span></span><br><span class="line"><span class="string">ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock</span></span><br></pre></td></tr></table></figure>
<p>初始密码设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> password <span class="keyword">for</span> root@localhost = password(<span class="string">'密码'</span>);</span><br><span class="line">grant all privileges on *.* to <span class="string">'对外用户名'</span>@<span class="string">'%'</span> identified by <span class="string">'对外密码'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<a id="more"></a>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>安装zsh</title>
    <url>/2019/05/12/Linux/%E5%AE%89%E8%A3%85zsh/</url>
    <content><![CDATA[<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><p><code>yum install -y zsh</code></p>
<a id="more"></a>
<p>装完之后验证一下最后一行有/bin/zsh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop3 ~]<span class="comment"># cat /etc/shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>
<p>切换shell为zsh</p>
<p><code>chsh -s /bin/zsh</code></p>
<p>然后echo $SHELL看还是bash，很多博客说要重启，其实只要退出终端重新打开就切换过来了。</p>
<h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><p><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></p>
<p>有时候连不上github的443端口，就直接下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>再重进登录一下终端就可以用了</p>
<p>查看主题</p>
<p><code>ls .oh-my-zsh/themes</code></p>
<p>把.zshrc里面的theme改成ys，提示符变成这样：</p>
<p><code># root @ hadoop3 in ~ [10:59:27]</code><br>安装自动提示插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mimosa-pudica.net/src/incr-0.2.zsh</span><br><span class="line">mkdir ~/.oh-my-zsh/plugins/incr</span><br><span class="line">mv incr-0.2.zsh ~/.oh-my-zsh/plugins/incr</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'source ~/.oh-my-zsh/plugins/incr/incr*.zsh'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>ok了，cd一下看看爽不爽。</p>
<h2 id="安装autojump"><a href="#安装autojump" class="headerlink" title="安装autojump"></a>安装autojump</h2><p>我yum源没有autojump，直接下载安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/joelthelion/autojump.git</span><br><span class="line">autojump/install.py</span><br></pre></td></tr></table></figure>
<p>安装完成在~/下面有.autojump目录，在.zshrc里面加一行</p>
<p><code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh</code></p>
<p>妥了，可以使用j了。 </p>
<p>我敲过一遍cd ~/go/src/learningGo/ch2以后如果换了当前目录，再敲j 2就回来了，爽</p>
<h2 id="让zsh支持Home键"><a href="#让zsh支持Home键" class="headerlink" title="让zsh支持Home键"></a>让zsh支持Home键</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;ENDOF &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="comment"># Home</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">'\e[1~'</span> beginning-of-line</span><br><span class="line"><span class="comment"># End</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">'\e[4~'</span> end-of-line</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keypad</span></span><br><span class="line"><span class="comment"># 0 . Enter</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Op"</span> <span class="string">"0"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Ol"</span> <span class="string">"."</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[OM"</span> <span class="string">"^M"</span></span><br><span class="line"><span class="comment"># 1 2 3</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Oq"</span> <span class="string">"1"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Or"</span> <span class="string">"2"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Os"</span> <span class="string">"3"</span></span><br><span class="line"><span class="comment"># 4 5 6</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Ot"</span> <span class="string">"4"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Ou"</span> <span class="string">"5"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Ov"</span> <span class="string">"6"</span></span><br><span class="line"><span class="comment"># 7 8 9</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Ow"</span> <span class="string">"7"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Ox"</span> <span class="string">"8"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Oy"</span> <span class="string">"9"</span></span><br><span class="line"><span class="comment"># + -  * /</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Ok"</span> <span class="string">"+"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Om"</span> <span class="string">"-"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Oj"</span> <span class="string">"*"</span></span><br><span class="line"><span class="built_in">bindkey</span> -s <span class="string">"^[Oo"</span> <span class="string">"/"</span></span><br><span class="line">ENDOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>作者：疯琴<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/qq_35753140/article/details/79551560" target="_blank" rel="noopener">https://blog.csdn.net/qq_35753140/article/details/79551560</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>安装libsodium库支持chacha20</title>
    <url>/2019/12/20/Linux/%E5%AE%89%E8%A3%85libsodium%E5%BA%93%E6%94%AF%E6%8C%81chacha20/</url>
    <content><![CDATA[<p>系统默认是没有 chacha20 加密方式的，需要手动编译 libsodium 1.0.8 及以上版本。安装需要以root权限安装</p>
<a id="more"></a>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h4 id="0-获取root权限"><a href="#0-获取root权限" class="headerlink" title="0.获取root权限"></a>0.获取root权限</h4><p><code>su root</code></p>
<h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><p>Debian 7/8、Ubuntu 14/15/16 及其衍生系列：</p>
<p><code>1. sudo apt-get update</code><br><code>2. sudo apt-get install build-essential wget -y</code></p>
<p>Centos 6/7、RHEL 7 及其衍生系列：</p>
<p><code>yum groupinstall &quot;Development Tools&quot; -y</code><br><code>yum install wget -y</code></p>
<h3 id="2-下载-libsodium-最新版本"><a href="#2-下载-libsodium-最新版本" class="headerlink" title="2. 下载 libsodium 最新版本"></a>2. 下载 libsodium 最新版本</h3><p>— 可以从libsodium 官网下，也可以从github 下载。选择速度最快的下载方式。</p>
<p><1> 从官网下载：</1></p>
<p><code>wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</code></p>
<p><2> 从 github 下载（其中 1.0.10 是 libusodium 的版本号，可以改成最新的）：</2></p>
<p><code>wget https://github.com/jedisct1/libsodium/releases/download/1.0.10/libsodium-1.0.10.tar.gz</code></p>
<h3 id="3-解压"><a href="#3-解压" class="headerlink" title="3. 解压"></a>3. 解压</h3><p><1>官网下载的：</1></p>
<p><code>tar xzvf LATEST.tar.gz</code></p>
<p><2>github 下载的：</2></p>
<p><code>tar xzvf libsodium-1.0.10.tar.gz</code></p>
<h3 id="4-生成配置文件"><a href="#4-生成配置文件" class="headerlink" title="4. 生成配置文件"></a>4. 生成配置文件</h3><p><code>cd libsodium*</code></p>
<p><code>./configure</code></p>
<h3 id="5-编译并安装"><a href="#5-编译并安装" class="headerlink" title="5. 编译并安装"></a>5. 编译并安装</h3><p><code>make -j8 &amp;&amp; make install</code></p>
<h3 id="6-添加运行库位置并加载运行库："><a href="#6-添加运行库位置并加载运行库：" class="headerlink" title="6. 添加运行库位置并加载运行库："></a>6. 添加运行库位置并加载运行库：</h3><p><code>echo /usr/local/lib &gt; /etc/ld.so.conf.d/usr_local_lib.conf</code></p>
<p><code>ldconfig</code></p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>安装libsodium库解决libsodium not found问题</p>
<p><a href="https://www.debugnode.com/ubuntul_ibsodium/" target="_blank" rel="noopener">https://www.debugnode.com/ubuntul_ibsodium/</a> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>更改CentOS主机名</title>
    <url>/2019/04/20/Linux/%E6%9B%B4%E6%94%B9CentOS%E4%B8%BB%E6%9C%BA%E5%90%8D/</url>
    <content><![CDATA[<p>在CentOS中，有三种定义的主机名:静态的（static），瞬态的（transient），和灵活的（pretty）。<code>静态</code>主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。<code>瞬态</code>主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。静态主机名和瞬态主机名都遵从作为互联网域名同样的字符限制规则。而另一方面，<code>灵活</code>主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如qqmm）。<br> 在CentOS 7中，有个叫hostnamectl的命令行工具，它允许你查看或修改与主机名相关的配置。</p>
<a id="more"></a>
<ol>
<li>要查看主机名相关的设置：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl</span><br><span class="line">   Static hostname: localhost.localdomain</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: 21ff9d4ebdd94e949b9fd6cbdb1926c0</span><br><span class="line">           Boot ID: 2a952e91c02841e3ae10de0d16dd3f01</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-327.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl status</span><br><span class="line">   Static hostname: localhost.localdomain</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: 21ff9d4ebdd94e949b9fd6cbdb1926c0</span><br><span class="line">           Boot ID: 2a952e91c02841e3ae10de0d16dd3f01</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-327.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure>
<ol>
<li>只查看静态、瞬态或灵活主机名，分别使用<code>--static</code>，<code>--transient</code>或<code>--pretty</code>选项。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl --static</span><br><span class="line">localhost.localdomain</span><br><span class="line">[root@localhost ~]# hostnamectl --transient</span><br><span class="line">localhost.localdomain</span><br><span class="line">[root@localhost ~]# hostnamectl --pretty</span><br></pre></td></tr></table></figure>
<ol>
<li>要同时修改所有三个主机名：静态、瞬态和灵活主机名：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl set-hostname qqmm</span><br><span class="line">[root@localhost ~]# hostnamectl --pretty</span><br><span class="line">[root@localhost ~]# hostnamectl --static</span><br><span class="line">qqmm</span><br><span class="line">[root@localhost ~]# hostnamectl --transient</span><br><span class="line">qqmm</span><br></pre></td></tr></table></figure>
<p>就像上面展示的那样，在修改静态/瞬态主机名时，任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。<br> 一旦修改了静态主机名，<code>/etc/hostname</code> 将被自动更新。然而，<code>/etc/hosts</code> 不会更新以保存所做的修改，所以你每次在修改主机名后一定要手动更新<code>/etc/hosts</code>，之后再重启CentOS 7。否则系统再启动时会很慢。</p>
<ol>
<li>手动更新<code>/etc/hosts</code> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">#127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">127.0.0.1  qqmm</span><br><span class="line">#::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">::1        qqmm</span><br></pre></td></tr></table></figure>
<ol>
<li>重启CentOS 7 之后<code>（reboot -f ）</code>，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qqmm ~]# hostname</span><br><span class="line">qqmm</span><br><span class="line">[root@qqmm ~]# hostnamectl</span><br><span class="line">   Static hostname: qqmm</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: 21ff9d4ebdd94e949b9fd6cbdb1926c0</span><br><span class="line">           Boot ID: 2a952e91c02841e3ae10de0d16dd3f01</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-327.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure>
<ol>
<li>如果你只想修改特定的主机名（静态，瞬态或灵活），你可以使用<code>--static</code>，<code>--transient</code>或<code>--pretty</code>选项。例如，要永久修改主机名，你可以修改静态主机名：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl --static set-hostname qqmm</span><br></pre></td></tr></table></figure>
<p>重启CentOS 7 之后（<code>reboot -f</code> ），</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl --static</span><br><span class="line">qqmm</span><br><span class="line">[root@localhost ~]# hostnamectl --transient</span><br><span class="line">qqmm</span><br><span class="line">[root@localhost ~]# hostnamectl --pretty</span><br><span class="line">qqmm</span><br><span class="line">[root@localhost ~]# hostname</span><br><span class="line">qqmm</span><br></pre></td></tr></table></figure>
<p>其实，你不必重启机器以激活永久主机名修改。上面的命令会立即修改内核主机名。<br> 注销并重新登入后在命令行提示来观察新的静态主机名</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.jianshu.com/p/39d7000dfa47" target="_blank" rel="noopener">https://www.jianshu.com/p/39d7000dfa47</a> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>打开Mac OSX原生的读写NTFS功能</title>
    <url>/2019/04/27/MacOS%E6%8A%80%E5%B7%A7/%E6%89%93%E5%BC%80Mac-OSX%E5%8E%9F%E7%94%9F%E7%9A%84%E8%AF%BB%E5%86%99NTFS%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>默认情况下，把一个NTFS格式的磁盘插入到Mac里，是只能读不能写的。网上一直流传着这么一个简单的方法是用第三方工具，Paragon NTFS for MAC。但是要收费，第二就是破解版还不一定能运行。其实最早在OSX 10.5的时候，OSX其实原生就支持直接写入NTFS的盘的，后来由于微软的限制，把这个功能给屏蔽了，我们可以通过命令行手动打开这个选项。</p>
<a id="more"></a>
<h3 id="1-插上磁盘"><a href="#1-插上磁盘" class="headerlink" title="1. 插上磁盘"></a>1. 插上磁盘</h3><p>此时Mac桌面应该会显示出插入的磁盘，但是当你想把文件拖入磁盘的时候，发现是不能拖进去的，这时候查看磁盘的属性应该是Windows NTFS格式的。</p>
<h3 id="2-打开终端"><a href="#2-打开终端" class="headerlink" title="2. 打开终端"></a>2. 打开终端</h3><h6 id="查看磁盘的Volume-Name"><a href="#查看磁盘的Volume-Name" class="headerlink" title="查看磁盘的Volume Name"></a>查看磁盘的Volume Name</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure>
<p>在终端键入如上命令可以看到你的磁盘的Volume Name，如我的Volume Name就是Elements。</p>
<h6 id="更新-etc-fstab文件"><a href="#更新-etc-fstab文件" class="headerlink" title="更新 /etc/fstab文件"></a>更新 /etc/fstab文件</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure>
<p>输入密码，然后输入<code>LABEL=Elements none ntfs rw,auto,nobrowse</code>，其中Elements就是你的磁盘名字。</p>
<p> 完成这里以后保存退出当前页面，然后重启电脑。</p>
<h6 id="显示磁盘在finder"><a href="#显示磁盘在finder" class="headerlink" title="显示磁盘在finder"></a>显示磁盘在finder</h6><p>当电脑重启完以后你会发现磁盘在你finder和桌面上都不显示了。因为这个Elements分区是挂/Volumes下的，我们把这个目录在桌面做一个快捷方式就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /Volumes/Elements ~/Desktop/Elements</span><br></pre></td></tr></table></figure>
<p>然后我们就可以再桌面上看到插入的磁盘了。</p>
<p>这时候就可以把文件拷贝到磁盘中去了。至此，打开系统原生的ntfs功能完成，妈妈再也不用担心我的硬盘。</p>
<p>以上 内容来源于一篇帖子：<br><a href="https://link.juejin.im/?target=http%3A%2F%2Fbbs.feng.com%2Fread-htm-tid-9932031.html" target="_blank" rel="noopener">bbs.feng.com/read-htm-ti…</a></p>
<h3 id="感谢作者。"><a href="#感谢作者。" class="headerlink" title="感谢作者。"></a>感谢作者。</h3>]]></content>
      <categories>
        <category>MacOS技巧</category>
      </categories>
  </entry>
  <entry>
    <title>使用virtualenv来管理系统环境变量</title>
    <url>/2020/09/13/MacOS%E6%8A%80%E5%B7%A7/%E4%BD%BF%E7%94%A8virtualenv%E6%9D%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>MacOS自带老掉牙的python2.7，因为删掉会破坏系统完整性，还不能乱删。让python3和python2和平相处就是系统环境变量管理的其中一个场景。<br>本文记录在MacOS下安装virtualenv，管理多套系统环境变量配置的方法。</p>
<a id="more"></a>
<h1 id="检查python和pip版本"><a href="#检查python和pip版本" class="headerlink" title="检查python和pip版本"></a>检查python和pip版本</h1><h2 id="检查Homebrew-Python更新"><a href="#检查Homebrew-Python更新" class="headerlink" title="检查Homebrew Python更新"></a>检查Homebrew Python更新</h2><p>更换Homebrew为中科大镜像源，在<code>~/.zshrc</code>中添加一行</p>
<pre><code>export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles
</code></pre><p>然后检查Python更新</p>
<pre><code>➜  hexo git:(master) ✗ brew upgrade python
Updating Homebrew...
Warning: python 3.8.5 already installed
</code></pre><h2 id="检查Python命令是否在3-8-5"><a href="#检查Python命令是否在3-8-5" class="headerlink" title="检查Python命令是否在3.8.5"></a>检查Python命令是否在3.8.5</h2><pre><code>➜  hexo git:(master) ✗ python -V
Python 3.8.5
➜  hexo git:(master) ✗ pip -V
pip 20.2.3 from /usr/local/lib/python3.8/site-packages/pip (python 3.8)
</code></pre><h2 id="pip使用中科大镜像源"><a href="#pip使用中科大镜像源" class="headerlink" title="pip使用中科大镜像源"></a>pip使用中科大镜像源</h2><p>特别注意，用阿里云的源会安装失败，特别坑。报错如下</p>
<pre><code>ERROR: Could not find a version that satisfies the requirement pbr (from versions: none)
</code></pre><p>更换镜像源需要添加文件： <code>~/.pip/pip.conf</code></p>
<pre><code>[global]
index-url=https://pypi.mirrors.ustc.edu.cn/simple/
[install]
trusted-host=pypi.mirrors.ustc.edu.cn
</code></pre><h1 id="安装与使用virtualenv"><a href="#安装与使用virtualenv" class="headerlink" title="安装与使用virtualenv"></a>安装与使用virtualenv</h1><h2 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h2><pre><code>sudo pip install virtualenvwrapper
</code></pre><p>创建文件夹用于存储环境<code>~/Envs</code>，在<code>~/.zshrc</code>中添加以下内容</p>
<pre><code>export WORKON_HOME=~/Envs
export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3

source /usr/local/bin/virtualenvwrapper.sh
</code></pre><h2 id="使用virtualenv（参考网上用法）"><a href="#使用virtualenv（参考网上用法）" class="headerlink" title="使用virtualenv（参考网上用法）"></a>使用virtualenv（参考网上用法）</h2><p>我们准备使用Python 3创建一个新的虚拟环境</p>
<pre><code>$  mkvirtualenv  --python=python3_path myenv
</code></pre><p>其中python3_path是python3的路径，可以在其中找到</p>
<pre><code>$  which python3
</code></pre><p>就我而言</p>
<pre><code>$  mkvirtualenv  --python=/usr/local/bin/python3 myenv
</code></pre><p>这将在环境文件夹〜/ .virtualenvs中创建一个文件夹myenv。运行上一个命令后，新环境将处于活动状态。要停用它，只需输入：</p>
<pre><code>$  deactivate
</code></pre><p>并再次激活它</p>
<pre><code>$  workon myenv
</code></pre><p>在你的python3虚拟环境中，如果你输入</p>
<pre><code>$  python
</code></pre><p>你激活python 3！此外，您可以使用pip调用pip3并安装python3包。</p>
<p>例如，您可以使用安装  Django 1.7</p>
<pre><code>$  pip install Django==1.7
</code></pre><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><pre><code>## 查看当前已有环境
➜  hexo git:(master) ✗ lsvirtualenv
test
====

## 删除环境 Test    
rmvirtualenv test    

</code></pre><h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source test/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ol>
<li><p><a href="https://cloud.tencent.com/developer/article/1182946" target="_blank" rel="noopener">在Mac OS X上安装Python 3并使用virtualenv和virtualenvwrapper</a></p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1019273143120480" target="_blank" rel="noopener">廖雪峰的官方网站</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>MacOS技巧</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB ibdata1文件导致MYSQL服务无法启动</title>
    <url>/2019/05/04/MySQL/MYSQL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%EF%BC%9A/</url>
    <content><![CDATA[<a id="more"></a>
<p>2015-01-07 17:48:54 9136 [ERROR] InnoDB: .\ibdata1 can’t be opened in read-write mode<br>2015-01-07 17:48:54 9136 [ERROR] InnoDB: The system tablespace must be writable!<br>2015-01-07 17:48:54 9136 [ERROR] Plugin ‘InnoDB’ init function returned error.<br>2015-01-07 17:48:54 9136 [ERROR] Plugin ‘InnoDB’ registration as a STORAGE ENGINE failed.<br>2015-01-07 17:48:54 9136 [ERROR] Unknown/unsupported storage engine: InnoDB<br>2015-01-07 17:48:54 9136 [ERROR] Aborting</p>
<p>解决方法：</p>
<p>1、打开任务管理器终止mysqld进程；</p>
<p>2、打开mysql安装目录的data文件夹，删除以下2个文件：</p>
<p>ib_logfile0和ib_logfile1</p>
<p>3、重新启动mysql</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>作者：indexman<br>来源：CSDN </p>
<p><a href="https://blog.csdn.net/IndexMan/article/details/42497137" target="_blank" rel="noopener">https://blog.csdn.net/IndexMan/article/details/42497137</a> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Group By的使用</title>
    <url>/2019/05/09/MySQL/Group-By%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。</p>
<a id="more"></a>
<h3 id="1、简单Group-By"><a href="#1、简单Group-By" class="headerlink" title="1、简单Group By"></a>1、简单Group By</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 类别, <span class="keyword">sum</span>(数量) <span class="keyword">AS</span> 数量之和</span><br><span class="line"><span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 类别</span><br></pre></td></tr></table></figure>
<p>对各类进行求和</p>
<h3 id="2、Group-By-和-Order-By联合使用"><a href="#2、Group-By-和-Order-By联合使用" class="headerlink" title="2、Group By 和 Order By联合使用"></a>2、Group By 和 Order By联合使用</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 类别, <span class="keyword">sum</span>(数量) <span class="keyword">AS</span> 数量之和</span><br><span class="line"><span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 类别</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">sum</span>(数量) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<h3 id="3、Group-By中Select指定的字段限制"><a href="#3、Group-By中Select指定的字段限制" class="headerlink" title="3、Group By中Select指定的字段限制"></a>3、Group By中Select指定的字段限制</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 类别, <span class="keyword">sum</span>(数量) <span class="keyword">as</span> 数量之和, 摘要</span><br><span class="line"><span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 类别</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 类别 <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
<p>在select指定的字段要么就要<strong>包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中</strong></p>
<h3 id="4、Group-By-All"><a href="#4、Group-By-All" class="headerlink" title="4、Group By All"></a>4、Group By All</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 类别, 摘要, <span class="keyword">sum</span>(数量) <span class="keyword">as</span> 数量之和</span><br><span class="line"><span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">all</span> 类别, 摘要</span><br></pre></td></tr></table></figure>
<p>示例中指定“摘要”字段，将类别和摘要一起作为联合索引。类别字段会重复</p>
<h3 id="5、Group-By与聚合函数"><a href="#5、Group-By与聚合函数" class="headerlink" title="5、Group By与聚合函数"></a>5、Group By与聚合函数</h3><p>在示例3中提到group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中，常见的聚合函数如下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>支持性</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum(列名)</td>
<td>求和</td>
<td></td>
</tr>
<tr>
<td>max(列名)</td>
<td>最大值</td>
<td></td>
</tr>
<tr>
<td>min(列名)</td>
<td>最小值</td>
<td></td>
</tr>
<tr>
<td>avg(列名)</td>
<td>平均值</td>
<td></td>
</tr>
<tr>
<td>first(列名)</td>
<td>第一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>last(列名)</td>
<td>最后一条记录</td>
<td>仅Access支持</td>
</tr>
<tr>
<td>count(列名)</td>
<td>统计记录数</td>
<td>注意和count(*)的区别</td>
</tr>
</tbody>
</table>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.cnblogs.com/rainman/archive/2013/05/01/3053703.html#m2" target="_blank" rel="noopener">https://www.cnblogs.com/rainman/archive/2013/05/01/3053703.html#m2</a> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>事务隔离级别</title>
    <url>/2019/08/04/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>MySQL事务隔离级别由弱到强分别为Read Committed，Snapshot Isolation，Repeatable Read，Serizable</p>
<a id="more"></a>
<h2 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h2><p>读提交名字来源是事务之外看不到未提交的事务，只有已提交的事务，外面才能看到。读提交主要是为了防止脏读。</p>
<blockquote>
<p>假定某个事务已经完成部分数据写入，但是没有提交（或中止），此时事务外是否可以看到尚未提交的数据？如果是的话，就是脏读。</p>
</blockquote>
<p><img src="C:\Users\shuiren\AppData\Local\Temp\1564885886206.png" alt="1564885886206"></p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>一行python代码实现ftp</title>
    <url>/2019/05/28/Python/%E4%B8%80%E8%A1%8Cpython%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0ftp/</url>
    <content><![CDATA[<p>python -m pyftpdlib</p>
<a id="more"></a>
<p>环境要求</p>
<p>·         Python 2.7</p>
<p>·         Windows / Linux</p>
<p>环境搭建</p>
<p>pip install pyftpdlib</p>
<p>一行代码实现FTP服务器</p>
<p>通过Python的-m选项作为一个简单的独立服务器来运行，当你想快速共享一个目录的时候，这是特别有用的。</p>
<p>在需要共享的目录下执行如下命令即可把当前目录共享出去（匿名登录）</p>
<p>python -m pyftpdlib</p>
<p>至此一个简单的FTP服务器已经搭建完成，访问 <a href="ftp://127.0.0.1:2121" target="_blank" rel="noopener">ftp://127.0.0.1:2121</a> 即可</p>
<p>（默认IP为 127.0.0.1 、端口为 2121 ）</p>
<p>可选参数</p>
<p>·         -i 指定IP地址（默认为本机的IP地址）</p>
<p>·         -p 指定端口（默认为2121）</p>
<p>·         -w 写权限（默认为只读）</p>
<p>·         -d 指定目录 （默认为当前目录）</p>
<p>·         -u 指定用户名登录</p>
<p>·         -P 设置登录密码</p>
<p>​    </p>
<p>简单示例</p>
<p>上述的一行命令已经可以实现一个简单的FTP服务器，但是要搭建一个功能强大完善的FTP服务所涉及到的配置较多，这时需要使用Pyftpdlib提供的 <a href="http://pyftpdlib.readthedocs.io/en/latest/api.html" target="_blank" rel="noopener">API</a> 来编写。如下是一个简单的示例</p>
<p>from pyftpdlib.authorizers import DummyAuthorizer</p>
<p>from pyftpdlib.handlers import FTPHandler</p>
<p>from pyftpdlib.servers import FTPServer</p>
<p># 实例化DummyAuthorizer来创建ftp用户</p>
<p>authorizer = DummyAuthorizer()</p>
<p># 参数：用户名，密码，目录，权限</p>
<p>authorizer.add_user(‘user’, ‘12345’, ‘/opt/pyftp/test’, perm=’elradfmwMT’)</p>
<p># 匿名登录</p>
<p># authorizer.add_anonymous(‘/home/nobody’)</p>
<p>handler = FTPHandler</p>
<p>handler.authorizer = authorizer</p>
<p># 参数：IP，端口，handler</p>
<p>server = FTPServer((‘192.168.56.100’, 21), handler)</p>
<p>server.serve_forever()</p>
<p>perm权限选项</p>
<p>读取权限：</p>
<p>·         “e” =更改目录（CWD，CDUP命令）</p>
<p>·         “l” =列表文件（LIST，NLST，STAT，MLSD，MLST，SIZE命令）</p>
<p>·         “r” =从服务器检索文件（RETR命令）</p>
<p>写入权限：</p>
<p>·         “a” =将数据追加到现有文件（APPE命令）</p>
<p>·         “d” =删除文件或目录（DELE，RMD命令）</p>
<p>·         “f” =重命名文件或目录（RNFR，RNTO命令）</p>
<p>·         “m” =创建目录（MKD命令）</p>
<p>·         “w” =将文件存储到服务器（STOR，STOU命令）</p>
<p>·         “M”=更改文件模式/权限（SITE CHMOD命令）</p>
<p>·         “T”=更改文件修改时间（SITE MFMT命令）</p>
<p>参考</p>
<p>Pyftpdlib文档：<a href="http://pyftpdlib.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">http://pyftpdlib.readthedocs.io/en/latest/index.html</a></p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p> 手把手教你用1行Python代码实现FTP服务器 – Pyftpdlib<br> <a href="https://my.oschina.net/kangvcar/blog/1599867" target="_blank" rel="noopener">https://my.oschina.net/kangvcar/blog/1599867</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>mysql手册</title>
    <url>/2020/07/31/MySQL/mysql%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>从网上摘录了一些常用SQL操作，以备即用即查</p>
<a id="more"></a>
<p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循署名-非商业用途-保持一致的创作共用协议.</p>
<p>MySQL是一种关系型数据库(RDBMS), 数据库可以理解为相关文件的集合. 数据库和控制器数据库的软件称为数据库管理系统(DBMS)</p>
<p>数据库提供处理数据的方法: SQL</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>每个表由多个行和列组成<br>每行包含一个单独实体的数据, 称为记录<br>每一列包含与该记录相关的一项数据, 称为属性</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本博文中所有的SQL语句遵循小写书写风格, 不喜勿喷</p>
<p>$ brew install mysql<br>$ mysql -u root mysql</p>
<h1 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h1><p>$ ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents </p>
<h1 id="加载mysql"><a href="#加载mysql" class="headerlink" title="加载mysql"></a>加载mysql</h1><p>$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</p>
<h1 id="启动mysql服务器"><a href="#启动mysql服务器" class="headerlink" title="启动mysql服务器"></a>启动mysql服务器</h1><p>$ mysql.server start</p>
<h1 id="关闭mysql服务器"><a href="#关闭mysql服务器" class="headerlink" title="关闭mysql服务器"></a>关闭mysql服务器</h1><p>$ mysql.server stop</p>
<h1 id="使用根用户"><a href="#使用根用户" class="headerlink" title="使用根用户"></a>使用根用户</h1><p>$ mysql -u root </p>
<h1 id="创建用户密码"><a href="#创建用户密码" class="headerlink" title="创建用户密码"></a>创建用户密码</h1><p>mysql&gt; set password=password(‘123456’);</p>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>mysql&gt; create database firstdb;</p>
<h1 id="添加用户和密码-并赋予firstdb的完全访问权限-账户名为amdin-密码为123456"><a href="#添加用户和密码-并赋予firstdb的完全访问权限-账户名为amdin-密码为123456" class="headerlink" title="添加用户和密码, 并赋予firstdb的完全访问权限, 账户名为amdin, 密码为123456"></a>添加用户和密码, 并赋予firstdb的完全访问权限, 账户名为amdin, 密码为123456</h1><p>mysql&gt; grant all on firstdb.* to admin@localhost identified by ‘123456’;  </p>
<h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><p>mysql&gt; exit</p>
<h2 id="初试数据库"><a href="#初试数据库" class="headerlink" title="初试数据库"></a>初试数据库</h2><h1 id="使用非根用户登陆数据库-并使用firstdb"><a href="#使用非根用户登陆数据库-并使用firstdb" class="headerlink" title="使用非根用户登陆数据库, 并使用firstdb"></a>使用非根用户登陆数据库, 并使用firstdb</h1><p>mysql&gt; mysql -u admin -p123456 firstdb</p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>mysql&gt; create table sales_rep(<br>    -&gt; employee_number int,<br>    -&gt; surname varchar(40),<br>    -&gt; first_name varchar(30),<br>    -&gt; commission tinyint<br>    -&gt; );</p>
<h1 id="显示已有表"><a href="#显示已有表" class="headerlink" title="显示已有表"></a>显示已有表</h1><p>mysql&gt; show tables;</p>
<h1 id="describe来检查表结构"><a href="#describe来检查表结构" class="headerlink" title="describe来检查表结构"></a>describe来检查表结构</h1><p>mysql&gt; describe sales_rep;<br>sales_rep为表名, employee_number, surname, first_name, commission为属性, int表示整型, varchar表示变长字符, tinyint表示小整数</p>
<h3 id="删除表和数据库"><a href="#删除表和数据库" class="headerlink" title="删除表和数据库"></a>删除表和数据库</h3><h1 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h1><p>mysql&gt; create table com(id int);</p>
<h1 id="删除表使用drop关键字"><a href="#删除表使用drop关键字" class="headerlink" title="删除表使用drop关键字"></a>删除表使用drop关键字</h1><p>mysql&gt; drop table com;</p>
<h1 id="切换root用户-创建数据库com"><a href="#切换root用户-创建数据库com" class="headerlink" title="切换root用户, 创建数据库com"></a>切换root用户, 创建数据库com</h1><p>mysql&gt; create database com;</p>
<h1 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h1><p>mysql&gt; drop database com;</p>
<h3 id="插入-删除-修改记录"><a href="#插入-删除-修改记录" class="headerlink" title="插入/删除/修改记录"></a>插入/删除/修改记录</h3><h1 id="插入数据-insert-into-表名-要插入的属性名-values-属性值-字符串使用单引号"><a href="#插入数据-insert-into-表名-要插入的属性名-values-属性值-字符串使用单引号" class="headerlink" title="插入数据 insert into 表名(要插入的属性名) values(属性值), 字符串使用单引号"></a>插入数据 insert into 表名(要插入的属性名) values(属性值), 字符串使用单引号</h1><p>mysql&gt; insert into sales_rep values(1, ‘Rive’, ‘Sol’, 10);<br>mysql&gt; insert into sales_rep values(2, ‘Gordimer’, ‘Charlens’, 15);<br>mysql&gt; insert into sales_rep values(3, ‘Serote’, ‘Mike’, 10);</p>
<h1 id="一行添加数据"><a href="#一行添加数据" class="headerlink" title="一行添加数据"></a>一行添加数据</h1><p>mysql&gt; insert into sales_rep values<br>     &gt;(1, ‘Rive’, ‘Sol’, 10),<br>     &gt;(2, ‘Gordimer’, ‘Charlens’, 15),<br>     &gt;(3, ‘Serote’, ‘Mike’, 10);</p>
<h1 id="从文件中加载数据-格式load-data-local-infile-“文件名”-into-table-表名"><a href="#从文件中加载数据-格式load-data-local-infile-“文件名”-into-table-表名" class="headerlink" title="从文件中加载数据, 格式load data local infile “文件名” into table 表名;"></a>从文件中加载数据, 格式load data local infile “文件名” into table 表名;</h1><p>mysql&gt; load data local infile “sales_rep.sql” into table sales_rep;<br>删除记录</p>
<h1 id="删除employee-number为5的记录"><a href="#删除employee-number为5的记录" class="headerlink" title="删除employee_number为5的记录"></a>删除employee_number为5的记录</h1><p>mysql&gt; delete from sales_rep where employee_number = 5;<br>修改记录</p>
<h1 id="修改employee-number的记录的commission为12"><a href="#修改employee-number的记录的commission为12" class="headerlink" title="修改employee_number的记录的commission为12"></a>修改employee_number的记录的commission为12</h1><p>mysql&gt; update sales_rep set commission = 12 where employee_number = 1;</p>
<h3 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h3><h1 id="检索所有插入的数据"><a href="#检索所有插入的数据" class="headerlink" title="检索所有插入的数据"></a>检索所有插入的数据</h1><p>mysql&gt; select * from sales_rep;</p>
<h1 id="检索surname为’Gordimer’的记录"><a href="#检索surname为’Gordimer’的记录" class="headerlink" title="检索surname为’Gordimer’的记录"></a>检索surname为’Gordimer’的记录</h1><p>mysql&gt; select * from sales_rep where surname=’Gordimer’;</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>like和%进行模糊查找</p>
<h1 id="输出已surname已R开头的数据"><a href="#输出已surname已R开头的数据" class="headerlink" title="输出已surname已R开头的数据"></a>输出已surname已R开头的数据</h1><p>mysql&gt; select * from sales_rep where surname like ‘R%’;</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>order by</p>
<h1 id="数据按照surname排序输出-当surname相同时-使用first-name排序"><a href="#数据按照surname排序输出-当surname相同时-使用first-name排序" class="headerlink" title="数据按照surname排序输出, 当surname相同时, 使用first_name排序"></a>数据按照surname排序输出, 当surname相同时, 使用first_name排序</h1><p>mysql&gt; select * from sales_rep order by surname, first_name;</p>
<h1 id="递减排序使用关键字desc-默认使用升序asc"><a href="#递减排序使用关键字desc-默认使用升序asc" class="headerlink" title="递减排序使用关键字desc, 默认使用升序asc"></a>递减排序使用关键字desc, 默认使用升序asc</h1><p>mysql&gt; select * from sales_rep order by surname desc;<br>多列排序时, 使用逗号隔开排序规则, order by排序优先次序为从左到右</p>
<p>mysql&gt; select ename, job, sal from emp  order by deptno asc, sal desc;<br>按照字符串部分子串排序</p>
<h1 id="按照job中最后两个字符进行排序"><a href="#按照job中最后两个字符进行排序" class="headerlink" title="按照job中最后两个字符进行排序"></a>按照job中最后两个字符进行排序</h1><p>mysql&gt; select ename, job from emp order by substr(job, length(job) - 1);<br>书中说: 找到字符串末尾(字符串长度)并减2, 则其实诶之就是字符串中倒数第二个字符</p>
<p>但在我测试过程用应该是建1, 则是对最后两个字符排序(疑问?)</p>
<p>根据数据项的键排序</p>
<p>使用case语句</p>
<p>如果job是salesman, 按照comm, 否则, 按照sal排序<br>mysql&gt; select ename, sal, job, comm from emp<br>    -&gt; order by case when job = ‘salesman’ then comm else sal end;</p>
<h3 id="限制数据数量"><a href="#限制数据数量" class="headerlink" title="限制数据数量"></a>限制数据数量</h3><p>limit</p>
<h1 id="按surname降序输出两行"><a href="#按surname降序输出两行" class="headerlink" title="按surname降序输出两行"></a>按surname降序输出两行</h1><p>mysql&gt; select * from sales_rep order by surname desc limit 2;<br>从表中随机返回n条记录</p>
<p>order by可以接受函数的返回值, 并使用它来改变结果集的顺序<br>select ename, job from emp order by rand() limit 5;</p>
<h3 id="最大值-最小值-计数-平均-综合"><a href="#最大值-最小值-计数-平均-综合" class="headerlink" title="最大值/最小值/计数/平均/综合"></a>最大值/最小值/计数/平均/综合</h3><h1 id="查询commission的最大值"><a href="#查询commission的最大值" class="headerlink" title="查询commission的最大值"></a>查询commission的最大值</h1><p>mysql&gt; select max(commission) from sales_rep;</p>
<h1 id="查询最小值"><a href="#查询最小值" class="headerlink" title="查询最小值"></a>查询最小值</h1><p>mysql&gt; select min(commission) from sales_rep;</p>
<h1 id="表中不重复surname的个数"><a href="#表中不重复surname的个数" class="headerlink" title="表中不重复surname的个数"></a>表中不重复surname的个数</h1><p>mysql&gt; select count(distinct surname) from sales_rep;</p>
<h1 id="commission的平均值"><a href="#commission的平均值" class="headerlink" title="commission的平均值"></a>commission的平均值</h1><p>mysql&gt; select avg(commission) from sales_rep;</p>
<h1 id="commission的总和"><a href="#commission的总和" class="headerlink" title="commission的总和"></a>commission的总和</h1><p>mysql&gt; select sum(commission) from sales_rep;</p>
<h1 id="right-从字符串右端算起-按位返回字符串"><a href="#right-从字符串右端算起-按位返回字符串" class="headerlink" title="right()从字符串右端算起, 按位返回字符串"></a>right()从字符串右端算起, 按位返回字符串</h1><p>mysql&gt; select right(date_joined, 5), right(birthday, 5) from sales_rep;</p>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><h1 id="使用distinct-去掉查询字段相同的记录"><a href="#使用distinct-去掉查询字段相同的记录" class="headerlink" title="使用distinct, 去掉查询字段相同的记录"></a>使用distinct, 去掉查询字段相同的记录</h1><h3 id="改变表结构"><a href="#改变表结构" class="headerlink" title="改变表结构"></a>改变表结构</h3><p>添加列</p>
<h1 id="给表添加一列名为data-joined-类型为date"><a href="#给表添加一列名为data-joined-类型为date" class="headerlink" title="给表添加一列名为data_joined, 类型为date"></a>给表添加一列名为data_joined, 类型为date</h1><p>mysql&gt; alter table sales_rep add date_joined date;</p>
<h1 id="添加一类名为year-born-类型为year"><a href="#添加一类名为year-born-类型为year" class="headerlink" title="添加一类名为year_born, 类型为year"></a>添加一类名为year_born, 类型为year</h1><p>alter table sales_rep add year_born year;<br>修改列定义</p>
<p>将year_born改为 列名为birthday, 类型为data<br>mysql&gt; alter table sales_rep change year_born birthday date;<br>重命名表</p>
<p>mysql&gt; alter table sales_rep rename cash_flow;</p>
<h1 id="恢复原来表名"><a href="#恢复原来表名" class="headerlink" title="恢复原来表名"></a>恢复原来表名</h1><p>mysql&gt; alter table cash_flow rename to sales_rep;<br>删除列</p>
<h1 id="删除列名为enhancement-value的一列"><a href="#删除列名为enhancement-value的一列" class="headerlink" title="删除列名为enhancement_value的一列"></a>删除列名为enhancement_value的一列</h1><p>mysql&gt; alter table sales_rep drop enhancement_value;</p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h1 id="给date类型设置日期"><a href="#给date类型设置日期" class="headerlink" title="给date类型设置日期"></a>给date类型设置日期</h1><p>mysql&gt; update sales_rep set date_joined = ‘2014-02-15’, birthday = ‘2000-02-14’ where employee_number = 1;</p>
<h1 id="使用日期函数-设置显示日期格式"><a href="#使用日期函数-设置显示日期格式" class="headerlink" title="使用日期函数, 设置显示日期格式"></a>使用日期函数, 设置显示日期格式</h1><p>mysql&gt; select date_format(date_joined, ‘%m/%d/%y’) from sales_rep;</p>
<h1 id="使用year-输出年-month-输出月-dayofmonth-输出一个月的第几日"><a href="#使用year-输出年-month-输出月-dayofmonth-输出一个月的第几日" class="headerlink" title="使用year()输出年, month()输出月, dayofmonth()输出一个月的第几日"></a>使用year()输出年, month()输出月, dayofmonth()输出一个月的第几日</h1><p>mysql&gt; select year(birthday), month(birthday), dayofmonth(birthday) from sales_rep;</p>
<h3 id="高级查找-别名-concat-多表查询-case表达式"><a href="#高级查找-别名-concat-多表查询-case表达式" class="headerlink" title="高级查找(别名, concat, 多表查询, case表达式)"></a>高级查找(别名, concat, 多表查询, case表达式)</h3><p>as起别名(类似pytho中import包时用as起别名)</p>
<p>mysql&gt; select year(birthday) as year, month(birthday) as month, dayofmonth(birthday) as day from sales_rep;<br>在别名的时候用别名做限定条件</p>
<p>from语句是在where之前完成的</p>
<h1 id="将查询结果作为内敛视图"><a href="#将查询结果作为内敛视图" class="headerlink" title="将查询结果作为内敛视图"></a>将查询结果作为内敛视图</h1><p>mysql&gt; select * from (select sal as salary, comm as commission from emp) x where salary &lt; 5000;<br>concat连接列</p>
<p>将多列作为一列进行输出</p>
<h1 id="将first-name-一个空格-surname连接在一起输出"><a href="#将first-name-一个空格-surname连接在一起输出" class="headerlink" title="将first_name, 一个空格, surname连接在一起输出"></a>将first_name, 一个空格, surname连接在一起输出</h1><p>mysql&gt; select concat(first_name, ‘ ‘, surname) as name, month(birthday) as month from sales_rep order by month;<br>mysql&gt; select concat(ename, ‘ works as a ‘, job) as msg from emp where deptno = 10;</p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>创建两个表并插入数据</p>
<p>mysql&gt; create table client(<br>    -&gt; id int,<br>    -&gt; first_name varchar(40),<br>    -&gt; surname varchar(30)<br>    -&gt; );<br>mysql&gt; create table sales(<br>    -&gt; code int,<br>    -&gt; sales_rep int,<br>    -&gt; customer int,<br>    -&gt; value int<br>    -&gt; );</p>
<p>mysql&gt; insert into customer values<br>    -&gt; (1, ‘Yvaonne’, ‘Clegg’),<br>    -&gt; (2, ‘Johnny’, ‘Chaka’),<br>    -&gt; (3, ‘Winston’, ‘Powers’),<br>    -&gt; (4, ‘Patricia’, ‘Mankunku’);<br>mysql&gt; insert into sales values<br>    -&gt; (1, 1, 1, 2000),<br>    -&gt; (2, 4, 3, 250),<br>    -&gt; (3, 2, 3, 500),<br>    -&gt; (4, 1, 4, 450),<br>    -&gt; (5, 3, 1, 3800),<br>    -&gt; (6, 1, 2, 500);<br>code为1, 且两表中employee_number和sales_rep的记录输出, select后面部分列出要返回的字段<br>mysql&gt; select sales_rep, customer, value, first_name, surname from sales, sales_rep where code = 1  and sales_rep.employee_number= sales.sales_rep;<br>case表达式</p>
<p>对select中的列值执行if-else操作</p>
<p>mysql&gt; select ename, sal,<br>    -&gt; case when sal &lt;= 2000 then ‘underpaid’<br>    -&gt; when sal &gt;= 4000 then ‘overpaid’<br>    -&gt; else ‘ok’        # else语句是可选的<br>    -&gt; end as status    # 对case语句返回的列取别名<br>    -&gt; from emp;</p>
<h3 id="查询中分组-不懂"><a href="#查询中分组-不懂" class="headerlink" title="查询中分组(不懂)"></a>查询中分组(不懂)</h3><p>group by指的是按照某个属性分组, 与其他组互不干扰</p>
<h1 id="查询每个sales-rep的value值的和"><a href="#查询每个sales-rep的value值的和" class="headerlink" title="查询每个sales_rep的value值的和"></a>查询每个sales_rep的value值的和</h1><p>mysql&gt; select sales_rep, sum(value) as sum from sales group by sales_rep;</p>
<h2 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h2><p>数字类型</p>
<p>int(整型), 表示整数<br>float/double分别表示单精度和双精度浮点数<br>字符类型</p>
<p>char(M) 固定长度为M的字符串, 字符串长度不够会补上空格 , 搜索时大小写无关<br>varchar(M), 可变长字符串(相比char一般比较节省内存), 搜索时大小写无关<br>text, 最大65535个字符, 搜索时大小写无关<br>blob, 最大65535个字符, 搜索时大小写相关<br>日期和时间类型</p>
<p>date, 默认格式YYYY-MM-DD, 可以使用date_format()函数更改输出方式<br>timestamp(M), 时间戳, YYYYMMDDHHMMSS, 可以指定不同长度的时间戳(M只影响显示)<br>time, 格式HH:MM:SS</p>
<h2 id="表类型"><a href="#表类型" class="headerlink" title="表类型"></a>表类型</h2><p>表类型    优点    缺点<br>静态表    速度快, 易缓存    要求更多的磁盘空间<br>动态表    占磁盘空间小    需要维护, 不易出问题后重建<br>压缩表    只读表类型, 占用很少磁盘空间    每条记录分开压缩, 不能同时访问<br>merge表    表尺寸小, 某些情况下速度快    eq_ref搜索慢, replace不能工作<br>heap表    散列索引, 最快    数据存在内存, 出现问题易丢失</p>
<h1 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h1><p>三表连接查找</p>
<p>mysql&gt; select sales_rep.first_name, sales_rep.surname,<br>    -&gt; value, customer.first_name, customer.surname<br>    -&gt; from sales, sales_rep, customer where sales_rep.employee_number = sales.sales_rep<br>    -&gt; and customer.id = sales.customer;<br>sales_rep表的employee_number与sales的sales_rep关联<br>customer表的id和sales的customer相关, 构成了连接条件</p>
<p>等值连接是一种内连接, 通过两个表或者多个表相等条件, 将两个表的行组合到一个表中.(内连接是连接的原始类型, 返回的每一行都包含来自每个表的数据)<br>mysql&gt; select ename, loc from emp, dept where emp.deptno = dept.deptno and emp.deptno = 10;</p>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h1 id="下面两句是等价的"><a href="#下面两句是等价的" class="headerlink" title="下面两句是等价的"></a>下面两句是等价的</h1><p>mysql&gt; select first_name, surname, value from customer, sales where customer.id = sales.customer;</p>
<h1 id="注意inner-join-表名-on-相关字段的SQL语句"><a href="#注意inner-join-表名-on-相关字段的SQL语句" class="headerlink" title="注意inner join 表名 on 相关字段的SQL语句"></a>注意inner join 表名 on 相关字段的SQL语句</h1><p>mysql&gt; select first_name, surname, value from customer inner join sales on customer.id = sales.customer;</p>
<h2 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h2><p>左连接就是返回左边匹配行, 不考虑右边的表是否有相应的行. 返回匹配的全部行的必须是左表, left join关键字之前</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>select field1, field2 from table1 left join table2 on field1 = field2;<br>mysql&gt; select first_name, surname, value from sales left join customer on id = customer;<br>右连接连接的顺序与左连接相反</p>
<h2 id="union链接"><a href="#union链接" class="headerlink" title="union链接"></a>union链接</h2><p>union用来把不同的select结果连接成一个, 每个语句必须有相同个数的列</p>
<p>union可能会进行去重处理, 不去重可以使用union all进行连接</p>
<p>union语句中order by是在整个union上进行的, 如果只想在某一个上使用可以请用小括号, union默认不返回重复记录</p>
<h1 id="创建一个表用于union查询"><a href="#创建一个表用于union查询" class="headerlink" title="创建一个表用于union查询"></a>创建一个表用于union查询</h1><p>mysql&gt; create table old_customer(<br>    -&gt; id int,<br>    -&gt; first_name varchar(30),<br>    -&gt; surnamr varchar(40));</p>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>mysql&gt; insert into old_customer values<br>    -&gt; (5432, ‘Thulani’, ‘Salis’),<br>    -&gt; (2342, ‘Shahiem’, ‘Papo’);</p>
<h1 id="两个查询语句有相同的列"><a href="#两个查询语句有相同的列" class="headerlink" title="两个查询语句有相同的列"></a>两个查询语句有相同的列</h1><p>mysql&gt; select id, first_name, surname from old_customer union select id, first_name, surname from customer;</p>
<h2 id="查询结果添加到另一个表"><a href="#查询结果添加到另一个表" class="headerlink" title="查询结果添加到另一个表"></a>查询结果添加到另一个表</h2><h1 id="创建一个用于插入的表"><a href="#创建一个用于插入的表" class="headerlink" title="创建一个用于插入的表"></a>创建一个用于插入的表</h1><p>mysql&gt; create table customer_sales_values(<br>    -&gt; first_name varchar(30),<br>    -&gt; surname varchar(40),<br>    -&gt; value int);<br>mysql&gt; insert into customer_sales_values(first_name, surname, value)<br>    -&gt; select first_name, surname, sum(value) from sales natural join customer group by first_name, surname;</p>
<h1 id="索引和查询优化"><a href="#索引和查询优化" class="headerlink" title="索引和查询优化"></a>索引和查询优化</h1><p>在MySQL中, 有四种类型的索引, 主键, 唯一索引, 全文索引和普通索引</p>
<p>主键(Primary Key)就是值唯一并且没有值为NULL的域的索引</p>
<p>主键不能包含NULL</p>
<h1 id="创建表-并设置主键"><a href="#创建表-并设置主键" class="headerlink" title="创建表, 并设置主键"></a>创建表, 并设置主键</h1><p>mysql&gt; create table pk_test(<br>    -&gt; f1 int not NULL,<br>    -&gt; primary key(f1));</p>
<h1 id="已存在的表上创建主键-语法-alter-table-tablename-add-primary-key-fieldname1-fieldname2"><a href="#已存在的表上创建主键-语法-alter-table-tablename-add-primary-key-fieldname1-fieldname2" class="headerlink" title="已存在的表上创建主键, 语法: alter table tablename add primary key(fieldname1 [, fieldname2])"></a>已存在的表上创建主键, 语法: alter table tablename add primary key(fieldname1 [, fieldname2])</h1><p>mysql&gt; alter table customer modify id int not null, add primary key(id);<br>普通索引容许重复的值</p>
<h1 id="创建普通索引语法-mysql-gt-create-table-fieldname-columntype-fieldname2-columntype-indexindexname"><a href="#创建普通索引语法-mysql-gt-create-table-fieldname-columntype-fieldname2-columntype-indexindexname" class="headerlink" title="创建普通索引语法 mysql&gt; create table(fieldname columntype, fieldname2 columntype, indexindexname);"></a>创建普通索引语法 mysql&gt; create table(fieldname columntype, fieldname2 columntype, index<a href="fieldname1 [,fieldname2...]">indexname</a>);</h1><h1 id="创建后添加索引-alter-table-tablename-add-indexindexname"><a href="#创建后添加索引-alter-table-tablename-add-indexindexname" class="headerlink" title="创建后添加索引: alter table tablename add indexindexname;"></a>创建后添加索引: alter table tablename add index<a href="fieldname1 [,fieldname2...]">indexname</a>;</h1><p>mysql&gt; alter table sales add index(value);<br>全文索引</p>
<h1 id="创建全文索引语法-mysql-gt-create-table-fieldname-columntype-fieldname2-columntype-fulltextindexname"><a href="#创建全文索引语法-mysql-gt-create-table-fieldname-columntype-fieldname2-columntype-fulltextindexname" class="headerlink" title="创建全文索引语法 mysql&gt; create table(fieldname columntype, fieldname2 columntype, fulltextindexname);"></a>创建全文索引语法 mysql&gt; create table(fieldname columntype, fieldname2 columntype, fulltext<a href="fieldname1 [,fieldname2...]">indexname</a>);</h1><p>mysql&gt; insert into ft2 values<br>    -&gt; (‘Waiting for the barbarians’),<br>    -&gt; (‘In the Heart of the Country’),<br>    -&gt; (‘The master of Patersbury’),<br>    -&gt; (‘Writing and Being’),<br>    -&gt; (‘Heart of the Beast’);<br>    -&gt; (‘Heart of the Beest’),<br>    -&gt; (‘The beginning and the End’),<br>    -&gt; (‘Master Master’),<br>    -&gt; (‘A barBarian at my door’);<br>Query OK, 4 rows affected (0.00 sec)</p>
<h1 id="创建表后再添加全文索引-alter-table-tablename-add-fulltextindexname"><a href="#创建表后再添加全文索引-alter-table-tablename-add-fulltextindexname" class="headerlink" title="创建表后再添加全文索引:alter table tablename add fulltextindexname;"></a>创建表后再添加全文索引:alter table tablename add fulltext<a href="fieldname1 [,fieldname2...]">indexname</a>;</h1><p>mysql&gt; create table ft(f1 varchar(255), f2 text, f3 blob, f4 int);<br>mysql&gt; alter table ft add fulltext(f1, f2);<br>全文索引的用法</p>
<p>文本域查找与大小写无关</p>
<h1 id="match-匹配属性-against-匹配值"><a href="#match-匹配属性-against-匹配值" class="headerlink" title="match()匹配属性, against()匹配值"></a>match()匹配属性, against()匹配值</h1><p>mysql&gt; select * from ft2 where match(f1) against (‘master’);<br>唯一索引除了不容许有重复的记录外, 与普通索引一样</p>
<h1 id="创建普通索引语法-mysql-gt-create-table-fieldname-columntype-fieldname2-columntype-unique-fieldname1-fieldname2…"><a href="#创建普通索引语法-mysql-gt-create-table-fieldname-columntype-fieldname2-columntype-unique-fieldname1-fieldname2…" class="headerlink" title="创建普通索引语法 mysql&gt; create table(fieldname columntype, fieldname2 columntype, unique(fieldname1 [,fieldname2…]));"></a>创建普通索引语法 mysql&gt; create table(fieldname columntype, fieldname2 columntype, unique(fieldname1 [,fieldname2…]));</h1><p>mysql&gt; create table ui_test(f1 int, f2 int, unique(f1));<br>mysql&gt; insert into ui_test values(1, 2);</p>
<h1 id="f1域不能包含重复值"><a href="#f1域不能包含重复值" class="headerlink" title="f1域不能包含重复值"></a>f1域不能包含重复值</h1><p>mysql&gt; insert into ui_test values(1, 3);<br>ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘f1’</p>
<h1 id="创建后添加索引-alter-table-tablename-add-uniqueindexname"><a href="#创建后添加索引-alter-table-tablename-add-uniqueindexname" class="headerlink" title="创建后添加索引: alter table tablename add uniqueindexname;"></a>创建后添加索引: alter table tablename add unique<a href="fieldname1 [,fieldname2...]">indexname</a>;</h1><h2 id="删除或者改变索引"><a href="#删除或者改变索引" class="headerlink" title="删除或者改变索引"></a>删除或者改变索引</h2><h1 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h1><p>alter table tablename drop primary key;</p>
<h1 id="删除普通-唯一-全文索引-需要制定索引名"><a href="#删除普通-唯一-全文索引-需要制定索引名" class="headerlink" title="删除普通, 唯一, 全文索引, 需要制定索引名"></a>删除普通, 唯一, 全文索引, 需要制定索引名</h1><p>alter table tablename frop index indexname;</p>
<h1 id="显示全部索引名"><a href="#显示全部索引名" class="headerlink" title="显示全部索引名"></a>显示全部索引名</h1><p>show keys from tablename;</p>
<h2 id="选择索引"><a href="#选择索引" class="headerlink" title="选择索引"></a>选择索引</h2><p>有查找需要使用索引的时候, 考虑创建索引<br>创建索引返回的行越少越好<br>私用短索引<br>不要创建太多的索引</p>
<h1 id="SQL-Cookbook"><a href="#SQL-Cookbook" class="headerlink" title="SQL Cookbook"></a>SQL Cookbook</h1><h2 id="查找空值"><a href="#查找空值" class="headerlink" title="查找空值"></a>查找空值</h2><p>查找空值切记不能用=操作, 会返回Empty Set</p>
<p>mysql&gt; select * from emp where comm is null;</p>
<h2 id="空值转换为实际值返回"><a href="#空值转换为实际值返回" class="headerlink" title="空值转换为实际值返回"></a>空值转换为实际值返回</h2><p>改变输入的形式, 但并不改变表中的数据</p>
<p>coalesce()函数有1个或者多个参数, comm非空时返回comm, null时返回0, 也可以用case语句判断实现</p>
<p>mysql&gt; select coalesce(comm, 0) from emp;</p>
<h2 id="从一个表中查找与其他表不匹配的记录"><a href="#从一个表中查找与其他表不匹配的记录" class="headerlink" title="从一个表中查找与其他表不匹配的记录"></a>从一个表中查找与其他表不匹配的记录</h2><p>外连接</p>
<p>mysql&gt; select d.* from dept d left outer join emp e<br>    -&gt; on (d.deptno = e.deptno) where e.deptno is null;</p>
<h2 id="插入更新删除"><a href="#插入更新删除" class="headerlink" title="插入更新删除"></a>插入更新删除</h2><h2 id="插入技巧"><a href="#插入技巧" class="headerlink" title="插入技巧"></a>插入技巧</h2><h2 id="从一个表向另外的表中复制行"><a href="#从一个表向另外的表中复制行" class="headerlink" title="从一个表向另外的表中复制行"></a>从一个表向另外的表中复制行</h2><p>解决方案: 在insert语句后面紧跟一个用来产生索要插入行的查询</p>
<p>mysql&gt; create table dept_east(<br>    -&gt; deptno int,<br>    -&gt; dname  varchar(30),<br>    -&gt; loc varchar(30));<br>mysql&gt; insert into dept_east(deptno, dname, loc)<br>    -&gt; select deptno, dname, loc from dept<br>    -&gt; where loc in(‘new york’, ‘boston’);</p>
<h2 id="赋值表定义"><a href="#赋值表定义" class="headerlink" title="赋值表定义"></a>赋值表定义</h2><p>只复制已有表的定义, 不复制其中的记录, 创建表的时候, 使用一个不返回任何行的子查询, where的条件时钟为false</p>
<p>mysql&gt; create table dept_2<br>    -&gt; as<br>    -&gt; select * from dept where 1 = 0;</p>
<h2 id="修改技巧"><a href="#修改技巧" class="headerlink" title="修改技巧"></a>修改技巧</h2><p>mysql&gt; update emp set sal = sal * 1.10 where deptno = 20;</p>
<h2 id="删除技巧"><a href="#删除技巧" class="headerlink" title="删除技巧"></a>删除技巧</h2><h3 id="删除所有记录"><a href="#删除所有记录" class="headerlink" title="删除所有记录"></a>删除所有记录</h3><p>mysql&gt; delete from dept_2;</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>MySQL Small Cookbook<br><a href="http://www.andrewliu.in/2015/05/24/MySQL_Small_Cookbook/index.html" target="_blank" rel="noopener">http://www.andrewliu.in/2015/05/24/MySQL_Small_Cookbook/index.html</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>VirtualBox vmdk文件缩容</title>
    <url>/2019/04/22/VirtualBox/VirtualBox-vmdk%E6%96%87%E4%BB%B6%E7%BC%A9%E5%AE%B9/</url>
    <content><![CDATA[<h4 id="一、清理虚拟机内的内容"><a href="#一、清理虚拟机内的内容" class="headerlink" title="一、清理虚拟机内的内容"></a>一、清理虚拟机内的内容</h4><p>df -hl 查看 各盘使用情况</p>
<p>使用 du -h –max-depth=1 </p>
<p>一步步找到占用大空间的文件夹</p>
<p>然后进行删除整理磁盘</p>
<h4 id="二、vmdk-k、-d命令缩容"><a href="#二、vmdk-k、-d命令缩容" class="headerlink" title="二、vmdk -k、-d命令缩容"></a>二、vmdk -k、-d命令缩容</h4><a id="more"></a>]]></content>
      <categories>
        <category>VirtualBox</category>
      </categories>
  </entry>
  <entry>
    <title>Windows命令行设置永久环境变量</title>
    <url>/2019/04/26/Windows/Windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE%E6%B0%B8%E4%B9%85%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>在cmd窗口中set设置的环境变量为临时变量，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set PATH=%PATH%;D:\Program Files\</span><br></pre></td></tr></table></figure>
<p>使用setx设置为永久环境变量,适用于bat中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setx PATH &quot;%PATH%;D:\Program Files\&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>基于go和etcd实现分布式锁</title>
    <url>/2019/04/20/etcd/%E5%9F%BA%E4%BA%8Ego%E5%92%8Cetcd%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"go.etcd.io/etcd/clientv3"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        config clientv3.Config</span><br><span class="line">        client *clientv3.Client</span><br><span class="line">        lease  clientv3.Lease</span><br><span class="line">        leaseResp *clientv3.LeaseGrantResponse</span><br><span class="line">        leaseId clientv3.LeaseID</span><br><span class="line">        leaseRespChan &lt;-<span class="keyword">chan</span> *clientv3.LeaseKeepAliveResponse</span><br><span class="line">        err    error</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//客户端配置</span></span><br><span class="line">    config = clientv3.Config&#123;</span><br><span class="line">        Endpoints:   []<span class="keyword">string</span>&#123;<span class="string">"127.0.0.1:2379"</span>&#125;,</span><br><span class="line">        DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立连接</span></span><br><span class="line">    <span class="keyword">if</span> client, err = clientv3.New(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上锁（创建租约，自动续租）</span></span><br><span class="line">    lease = clientv3.NewLease(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个ctx取消自动续租</span></span><br><span class="line">    ctx,cancleFunc := context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置10秒租约（过期时间）</span></span><br><span class="line">    <span class="keyword">if</span> leaseResp,err = lease.Grant(context.TODO(),<span class="number">10</span>);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿到租约id</span></span><br><span class="line">    leaseId = leaseResp.ID</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动续租（不停地往管道中扔租约信息）</span></span><br><span class="line">    <span class="keyword">if</span> leaseRespChan,err =lease.KeepAlive(ctx,leaseId);err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动一个协程去监听</span></span><br><span class="line">    <span class="keyword">go</span> listenLeaseChan(leaseRespChan)</span><br><span class="line">    <span class="comment">//业务处理</span></span><br><span class="line">    kv := clientv3.NewKV(client)</span><br><span class="line">    <span class="comment">//创建事务</span></span><br><span class="line">    txn := kv.Txn(context.TODO())</span><br><span class="line">    txn.If(clientv3.Compare(clientv3.CreateRevision(<span class="string">"/cron/lock/job9"</span>),<span class="string">"="</span>,<span class="number">0</span>)).</span><br><span class="line">        Then(clientv3.OpPut(<span class="string">"/cron/lock/job9"</span>,<span class="string">"xxx"</span>,clientv3.WithLease(leaseId))).</span><br><span class="line">        Else(clientv3.OpGet(<span class="string">"/cron/lock/job9"</span>))<span class="comment">//否则抢锁失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">if</span> txtResp,err :=txn.Commit();err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否抢锁</span></span><br><span class="line">        <span class="keyword">if</span> !txtResp.Succeeded &#123;</span><br><span class="line">            fmt.Println(<span class="string">"锁被占用："</span>,<span class="keyword">string</span>(txtResp.Responses[<span class="number">0</span>].GetResponseRange().Kvs[<span class="number">0</span>].Value))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"处理任务"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁（停止续租，终止租约）</span></span><br><span class="line">    <span class="keyword">defer</span> cancleFunc()<span class="comment">//函数退出取消自动续租</span></span><br><span class="line">    <span class="keyword">defer</span> lease.Revoke(context.TODO(),leaseId) <span class="comment">//终止租约（去掉过期时间）</span></span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listenLeaseChan</span><span class="params">(leaseRespChan &lt;-<span class="keyword">chan</span> *clientv3.LeaseKeepAliveResponse)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        leaseKeepResp *clientv3.LeaseKeepAliveResponse</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> leaseKeepResp = &lt;-leaseRespChan:</span><br><span class="line">            <span class="keyword">if</span> leaseKeepResp == <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"租约失效了"</span>)</span><br><span class="line">                <span class="keyword">goto</span> END</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(leaseKeepResp.ID)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    END:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.jianshu.com/p/d3068d0ac7c1" target="_blank" rel="noopener">https://www.jianshu.com/p/d3068d0ac7c1</a> </p>
<a id="more"></a>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>go</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>ZK可视化工具</title>
    <url>/2019/12/10/ZK/ZK%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>下载地址 <a href="https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip" target="_blank" rel="noopener">https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</a> </p>
<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>ZooKeeper客户端监控软件ZooInspector</p>
<p> <a href="https://blog.52itstyle.vip/archives/343/" target="_blank" rel="noopener">https://blog.52itstyle.vip/archives/343/</a> </p>
]]></content>
      <categories>
        <category>ZK</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 搭建 etcd 集群</title>
    <url>/2019/04/22/etcd/Docker-%E6%90%AD%E5%BB%BA-etcd-%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<ul>
<li><strong>主机安装</strong></li>
<li><strong>集群搭建</strong></li>
<li><strong>API 操作</strong></li>
<li><strong>API 说明和 etcdctl 命令说明</strong><a id="more"></a>
</li>
</ul>
<p><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">etcd</a> 是 CoreOS 团队发起的一个开源项目（Go 语言，其实很多这类项目都是 Go 语言实现的，只能说很强大），实现了<strong>分布式键值存储</strong>和<strong>服务发现</strong>，etcd 和 ZooKeeper/Consul 非常相似，都提供了类似的功能，以及 REST API 的访问操作，具有以下特点：</p>
<ul>
<li>简单：安装和使用简单，提供了 REST API 进行操作交互</li>
<li>安全：支持 HTTPS SSL 证书</li>
<li>快速：支持并发 10 k/s 的读写操作</li>
<li>可靠：采用 raft 算法，实现分布式系统数据的可用性和一致性</li>
</ul>
<p>etcd 可以单个实例使用，也可以进行集群配置，因为很多项目都是以 etcd 作为服务发现，比如 CoreOS 和 Kubernetes，所以，下面我们使用 Docker 简单搭建一下 etcd 集群。</p>
<p><img src="https://images2018.cnblogs.com/blog/435188/201712/435188-20171225173221197-831704411.png" alt="img"></p>
<h2 id="1-主机安装"><a href="#1-主机安装" class="headerlink" title="1. 主机安装"></a>1. 主机安装</h2><p>如果不使用 Docker 的话，etcd 在主机上安装，也非常简单。</p>
<p>Linux 安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -L  https://github.com/coreos/etcd/releases/download/v3.3.0-rc.0/etcd-v3.3.0-rc.0-linux-amd64.tar.gz -o etcd-v3.3.0-rc.0-linux-amd64.tar.gz &amp;&amp; </span><br><span class="line">sudo tar xzvf etcd-v3.3.0-rc.0-linux-amd64.tar.gz &amp;&amp; </span><br><span class="line">cd etcd-v3.3.0-rc.0-linux-amd64 &amp;&amp; </span><br><span class="line">sudo cp etcd* /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>其实就是将编译后的二进制文件，拷贝到<code>/usr/local/bin/</code>目录，各个版本的二进制文件，可以从 <a href="https://github.com/coreos/etcd/releases/" target="_blank" rel="noopener">https://github.com/coreos/etcd/releases/</a> 中查找下载。</p>
<p>Mac OS 安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt; /dev/null 2&gt; /dev/null</span><br><span class="line">$ brew install etcd</span><br></pre></td></tr></table></figure>
<p>执行下面命令，查看 etcd 是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcd --version</span><br><span class="line">etcd Version: 3.2.12</span><br><span class="line">Git SHA: GitNotFound</span><br><span class="line">Go Version: go1.9.2</span><br><span class="line">Go OS/Arch: darwin/amd64</span><br></pre></td></tr></table></figure>
<h2 id="2-集群搭建"><a href="#2-集群搭建" class="headerlink" title="2. 集群搭建"></a>2. 集群搭建</h2><p>搭建 etcd 集群，需要借助下 Docker Machine 创建三个 Docker 主机，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox manager1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker2</span><br><span class="line"></span><br><span class="line">$ docker-machine ls</span><br><span class="line">NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">manager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.11.0-ce   </span><br><span class="line">worker1    -        virtualbox   Running   tcp://192.168.99.101:2376           v17.11.0-ce   </span><br><span class="line">worker2    -        virtualbox   Running   tcp://192.168.99.102:2376           v17.11.0-ce</span><br></pre></td></tr></table></figure>
<p>为防止 Docker 主机中垃取官方镜像，速度慢的问题，我们还需要将 etcd 镜像打包推送到私有仓库中，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker tag quay.io/coreos/etcd 192.168.99.1:5000/quay.io/coreos/etcd:latest &amp;&amp; </span><br><span class="line">docker push 192.168.99.1:5000/quay.io/coreos/etcd:latest &amp;&amp; </span><br><span class="line">docker pull 192.168.99.1:5000/quay.io/coreos/etcd:latest</span><br></pre></td></tr></table></figure>
<p>另外，还需要将私有仓库地址配置在 Docker 主机中，并重启三个 Docker 主机，具体配置参考：<a href="http://www.cnblogs.com/xishuai/p/docker-swarm.html" target="_blank" rel="noopener">Docker 三剑客之 Docker Swarm</a></p>
<hr>
<p>Docker 主机配置好之后，我们需要使用<code>docker-machine ssh</code>命令，分别进入三个 Docker 主机中，执行 Docker etcd 配置命令。</p>
<p>manager1 主机（<code>node1 192.168.99.100</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume=etcd-data:/etcd-data \</span><br><span class="line">    192.168.99.1:5000/quay.io/coreos/etcd \</span><br><span class="line">    /usr/local/bin/etcd \</span><br><span class="line">    --data-dir=/etcd-data --name node1 \</span><br><span class="line">    --initial-advertise-peer-urls http://192.168.99.100:2380 --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">    --advertise-client-urls http://192.168.99.100:2379 --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">    --initial-cluster-state new \</span><br><span class="line">    --initial-cluster-token docker-etcd \</span><br><span class="line">    --initial-cluster node1=http://192.168.99.100:2380,node2=http://192.168.99.101:2380,node3=http://192.168.99.102:2380</span><br></pre></td></tr></table></figure>
<p>worker1 主机（<code>node2 192.168.99.101</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume=etcd-data:/etcd-data \</span><br><span class="line">    192.168.99.1:5000/quay.io/coreos/etcd \</span><br><span class="line">    /usr/local/bin/etcd \</span><br><span class="line">    --data-dir=/etcd-data --name node2 \</span><br><span class="line">    --initial-advertise-peer-urls http://192.168.99.101:2380 --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">    --advertise-client-urls http://192.168.99.101:2379 --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">    --initial-cluster-state new \</span><br><span class="line">    --initial-cluster-token docker-etcd \</span><br><span class="line">    --initial-cluster node1=http://192.168.99.100:2380,node2=http://192.168.99.101:2380,node3=http://192.168.99.102:2380</span><br></pre></td></tr></table></figure>
<p>worker2 主机（<code>node1 192.168.99.102</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume=etcd-data:/etcd-data \</span><br><span class="line">    192.168.99.1:5000/quay.io/coreos/etcd \</span><br><span class="line">    /usr/local/bin/etcd \</span><br><span class="line">    --data-dir=/etcd-data --name node3 \</span><br><span class="line">    --initial-advertise-peer-urls http://192.168.99.102:2380 --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">    --advertise-client-urls http://192.168.99.102:2379 --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">    --initial-cluster-state existing \</span><br><span class="line">    --initial-cluster-token docker-etcd \</span><br><span class="line">    --initial-cluster node1=http://192.168.99.100:2380,node2=http://192.168.99.101:2380,node3=http://192.168.99.102:2380</span><br></pre></td></tr></table></figure>
<p>先来说明下 etcd 各个配置参数的意思（参考自 <a href="http://cizixs.com/2016/08/02/intro-to-etcd" target="_blank" rel="noopener">etcd 使用入门</a>）：</p>
<ul>
<li><code>--name</code>：节点名称，默认为 default。</li>
<li><code>--data-dir</code>：服务运行数据保存的路径，默认为<code>${name}.etcd</code>。</li>
<li><code>--snapshot-count</code>：指定有多少事务（transaction）被提交时，触发截取快照保存到磁盘。</li>
<li><code>--heartbeat-interval</code>：leader 多久发送一次心跳到 followers。默认值是 100ms。</li>
<li><code>--eletion-timeout</code>：重新投票的超时时间，如果 follow 在该时间间隔没有收到心跳包，会触发重新投票，默认为 1000 ms。</li>
<li><code>--listen-peer-urls</code>：和同伴通信的地址，比如<code>http://ip:2380</code>，如果有多个，使用逗号分隔。需要所有节点都能够访问，所以不要使用 localhost！</li>
<li><code>--listen-client-urls</code>：对外提供服务的地址：比如<code>http://ip:2379,http://127.0.0.1:2379</code>，客户端会连接到这里和 etcd 交互。</li>
<li><code>--advertise-client-urls</code>：对外公告的该节点客户端监听地址，这个值会告诉集群中其他节点。</li>
<li><code>--initial-advertise-peer-urls</code>：该节点同伴监听地址，这个值会告诉集群中其他节点。</li>
<li><code>--initial-cluster</code>：集群中所有节点的信息，格式为<code>node1=http://ip1:2380,node2=http://ip2:2380,…</code>，注意：这里的 node1 是节点的 –name 指定的名字；后面的 ip1:2380 是 –initial-advertise-peer-urls 指定的值。</li>
<li><code>--initial-cluster-state</code>：新建集群的时候，这个值为 new；假如已经存在的集群，这个值为 existing。</li>
<li><code>--initial-cluster-token</code>：创建集群的 token，这个值每个集群保持唯一。这样的话，如果你要重新创建集群，即使配置和之前一样，也会再次生成新的集群和节点 uuid；否则会导致多个集群之间的冲突，造成未知的错误。</li>
</ul>
<p>上述配置也可以设置配置文件，默认为<code>/etc/etcd/etcd.conf</code>。</p>
<p>我们可以使用<code>docker ps</code>，查看 Docker etcd 是否配置成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                   COMMAND                  CREATED             STATUS              PORTS                              NAMES</span><br><span class="line">463380d23dfe        192.168.99.1:5000/quay.io/coreos/etcd   &quot;/usr/local/bin/et...&quot;   2 hours ago         Up 2 hours          0.0.0.0:2379-2380-&gt;2379-2380/tcp   etcd</span><br></pre></td></tr></table></figure>
<p>然后进入其中一个 Docker 主机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -it etcd bin/sh</span><br></pre></td></tr></table></figure>
<p>执行下面命令（查看集群成员）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member list</span><br><span class="line">773d30c9fc6640b4: name=node2 peerURLs=http://192.168.99.101:2380 clientURLs=http://192.168.99.101:2379 isLeader=true</span><br><span class="line">b2b0bca2e0cfcc19: name=node3 peerURLs=http://192.168.99.102:2380 clientURLs=http://192.168.99.102:2379 isLeader=false</span><br><span class="line">c88e2cccbb287a01: name=node1 peerURLs=http://192.168.99.100:2380 clientURLs=http://192.168.99.100:2379 isLeader=false</span><br></pre></td></tr></table></figure>
<p>可以看到，集群里面有三个成员，并且<code>node2</code>为管理员，<code>node1</code>和<code>node3</code>为普通成员。</p>
<p>etcdctl 是 ectd 的客户端命令工具（也是 go 语言实现），里面封装了 etcd 的 REST API 执行命令，方便我们进行操作 etcd，后面再列出 etcdctl 的命令详细说明。</p>
<p>上面命令的 etcd API 版本为 2.0，我们可以手动设置版本为 3.0，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export ETCDCTL_API=3 &amp;&amp; /usr/local/bin/etcdctl put foo bar</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>部分命令和执行结果还是和 2.0 版本，有很多不同的，比如同是查看集群成员，3.0 版本的执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member list</span><br><span class="line">773d30c9fc6640b4, started, node2, http://192.168.99.101:2380, http://192.168.99.101:2379</span><br><span class="line">b2b0bca2e0cfcc19, started, node3, http://192.168.99.102:2380, http://192.168.99.102:2379</span><br><span class="line">c88e2cccbb287a01, started, node1, http://192.168.99.100:2380, http://192.168.99.100:2379</span><br></pre></td></tr></table></figure>
<hr>
<p>好了，我们现在再演示一种情况，就是从集群中移除一个节点，然后再把它添加到集群中，为演示 etcd 中使用 Raft 算法，我们将<code>node2</code>管理节点，作为操作对象。</p>
<p>我们在随便一个主机 etcd 容器中（<code>node2</code>除外），执行成员移除集群命令（必须使用 ID，使用别名会报错）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member remove 773d30c9fc6640b4</span><br><span class="line">Member 773d30c9fc6640b4 removed from cluster f84185fa5f91bdf6</span><br></pre></td></tr></table></figure>
<p>我们再执行下查看集群成员命令（v2 版本）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member list</span><br><span class="line">b2b0bca2e0cfcc19: name=node3 peerURLs=http://192.168.99.102:2380 clientURLs=http://192.168.99.102:2379 isLeader=true</span><br><span class="line">c88e2cccbb287a01: name=node1 peerURLs=http://192.168.99.100:2380 clientURLs=http://192.168.99.100:2379 isLeader=false</span><br></pre></td></tr></table></figure>
<p>会发现<code>node2</code>管理节点被移除集群了，并且通过 Raft 算法，<code>node3</code>被推举为管理节点。</p>
<p>在将<code>node2</code>节点重新加入集群之前，我们需要执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member add node2 --peer-urls=&quot;http://192.168.99.101:2380&quot;</span><br><span class="line">Member 22b0de6ffcd98f00 added to cluster f84185fa5f91bdf6</span><br><span class="line"></span><br><span class="line">ETCD_NAME=&quot;node2&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;node2=http://192.168.99.101:2380,node3=http://192.168.99.102:2380,node1=http://192.168.99.100:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到，ETCD_INITIAL_CLUSTER_STATE 值为<code>existing</code>，也就是我们配置的<code>--initial-cluster-state</code>参数。</p>
<p>我们再执行下查看集群成员命令（v2 版本）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member list</span><br><span class="line">22b0de6ffcd98f00[unstarted]: peerURLs=http://192.168.99.101:2380</span><br><span class="line">b2b0bca2e0cfcc19: name=node3 peerURLs=http://192.168.99.102:2380 clientURLs=http://192.168.99.102:2379 isLeader=true</span><br><span class="line">c88e2cccbb287a01: name=node1 peerURLs=http://192.168.99.100:2380 clientURLs=http://192.168.99.100:2379 isLeader=false</span><br></pre></td></tr></table></figure>
<p>会发现<code>22b0de6ffcd98f00</code>成员状态变为了<code>unstarted</code>。</p>
<p>我们在<code>node2</code>节点，执行 Docker etcd 集群配置命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name etcd \</span><br><span class="line">    -p 2379:2379 \</span><br><span class="line">    -p 2380:2380 \</span><br><span class="line">    --volume=etcd-data:/etcd-data \</span><br><span class="line">    192.168.99.1:5000/quay.io/coreos/etcd \</span><br><span class="line">    /usr/local/bin/etcd \</span><br><span class="line">    --data-dir=/etcd-data --name node2 \</span><br><span class="line">    --initial-advertise-peer-urls http://192.168.99.101:2380 --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">    --advertise-client-urls http://192.168.99.101:2379 --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">    --initial-cluster-state existing \</span><br><span class="line">    --initial-cluster-token docker-etcd \</span><br><span class="line">    --initial-cluster node1=http://192.168.99.100:2380,node2=http://192.168.99.101:2380,node3=http://192.168.99.102:2380</span><br></pre></td></tr></table></figure>
<p>结果并不像我们想要的那样成功，执行查看日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker logs etcd</span><br><span class="line">2017-12-25 08:19:30.160967 I | etcdmain: etcd Version: 3.2.12</span><br><span class="line">2017-12-25 08:19:30.161062 I | etcdmain: Git SHA: b19dae0</span><br><span class="line">2017-12-25 08:19:30.161082 I | etcdmain: Go Version: go1.8.5</span><br><span class="line">2017-12-25 08:19:30.161092 I | etcdmain: Go OS/Arch: linux/amd64</span><br><span class="line">2017-12-25 08:19:30.161105 I | etcdmain: setting maximum number of CPUs to 1, total number of available CPUs is 1</span><br><span class="line">2017-12-25 08:19:30.161144 N | etcdmain: the server is already initialized as member before, starting as etcd member...</span><br><span class="line">2017-12-25 08:19:30.161195 I | embed: listening for peers on http://0.0.0.0:2380</span><br><span class="line">2017-12-25 08:19:30.161232 I | embed: listening for client requests on 0.0.0.0:2379</span><br><span class="line">2017-12-25 08:19:30.165269 I | etcdserver: name = node2</span><br><span class="line">2017-12-25 08:19:30.165317 I | etcdserver: data dir = /etcd-data</span><br><span class="line">2017-12-25 08:19:30.165335 I | etcdserver: member dir = /etcd-data/member</span><br><span class="line">2017-12-25 08:19:30.165347 I | etcdserver: heartbeat = 100ms</span><br><span class="line">2017-12-25 08:19:30.165358 I | etcdserver: election = 1000ms</span><br><span class="line">2017-12-25 08:19:30.165369 I | etcdserver: snapshot count = 100000</span><br><span class="line">2017-12-25 08:19:30.165385 I | etcdserver: advertise client URLs = http://192.168.99.101:2379</span><br><span class="line">2017-12-25 08:19:30.165593 I | etcdserver: restarting member 773d30c9fc6640b4 in cluster f84185fa5f91bdf6 at commit index 14</span><br><span class="line">2017-12-25 08:19:30.165627 I | raft: 773d30c9fc6640b4 became follower at term 11</span><br><span class="line">2017-12-25 08:19:30.165647 I | raft: newRaft 773d30c9fc6640b4 [peers: [], term: 11, commit: 14, applied: 0, lastindex: 14, lastterm: 11]</span><br><span class="line">2017-12-25 08:19:30.169277 W | auth: simple token is not cryptographically signed</span><br><span class="line">2017-12-25 08:19:30.170424 I | etcdserver: starting server... [version: 3.2.12, cluster version: to_be_decided]</span><br><span class="line">2017-12-25 08:19:30.171732 I | etcdserver/membership: added member 773d30c9fc6640b4 [http://192.168.99.101:2380] to cluster f84185fa5f91bdf6</span><br><span class="line">2017-12-25 08:19:30.171845 I | etcdserver/membership: added member c88e2cccbb287a01 [http://192.168.99.100:2380] to cluster f84185fa5f91bdf6</span><br><span class="line">2017-12-25 08:19:30.171877 I | rafthttp: starting peer c88e2cccbb287a01...</span><br><span class="line">2017-12-25 08:19:30.171902 I | rafthttp: started HTTP pipelining with peer c88e2cccbb287a01</span><br><span class="line">2017-12-25 08:19:30.175264 I | rafthttp: started peer c88e2cccbb287a01</span><br><span class="line">2017-12-25 08:19:30.175339 I | rafthttp: added peer c88e2cccbb287a01</span><br><span class="line">2017-12-25 08:19:30.178326 I | etcdserver/membership: added member cbd7fa8d01297113 [http://192.168.99.102:2380] to cluster f84185fa5f91bdf6</span><br><span class="line">2017-12-25 08:19:30.178383 I | rafthttp: starting peer cbd7fa8d01297113...</span><br><span class="line">2017-12-25 08:19:30.178410 I | rafthttp: started HTTP pipelining with peer cbd7fa8d01297113</span><br><span class="line">2017-12-25 08:19:30.179794 I | rafthttp: started peer cbd7fa8d01297113</span><br><span class="line">2017-12-25 08:19:30.179835 I | rafthttp: added peer cbd7fa8d01297113</span><br><span class="line">2017-12-25 08:19:30.180062 N | etcdserver/membership: set the initial cluster version to 3.0</span><br><span class="line">2017-12-25 08:19:30.180132 I | etcdserver/api: enabled capabilities for version 3.0</span><br><span class="line">2017-12-25 08:19:30.180255 N | etcdserver/membership: updated the cluster version from 3.0 to 3.2</span><br><span class="line">2017-12-25 08:19:30.180430 I | etcdserver/api: enabled capabilities for version 3.2</span><br><span class="line">2017-12-25 08:19:30.183979 I | rafthttp: started streaming with peer c88e2cccbb287a01 (writer)</span><br><span class="line">2017-12-25 08:19:30.184139 I | rafthttp: started streaming with peer c88e2cccbb287a01 (writer)</span><br><span class="line">2017-12-25 08:19:30.184232 I | rafthttp: started streaming with peer c88e2cccbb287a01 (stream MsgApp v2 reader)</span><br><span class="line">2017-12-25 08:19:30.185142 I | rafthttp: started streaming with peer c88e2cccbb287a01 (stream Message reader)</span><br><span class="line">2017-12-25 08:19:30.186518 I | etcdserver/membership: removed member cbd7fa8d01297113 from cluster f84185fa5f91bdf6</span><br><span class="line">2017-12-25 08:19:30.186573 I | rafthttp: stopping peer cbd7fa8d01297113...</span><br><span class="line">2017-12-25 08:19:30.186614 I | rafthttp: started streaming with peer cbd7fa8d01297113 (writer)</span><br><span class="line">2017-12-25 08:19:30.186786 I | rafthttp: stopped streaming with peer cbd7fa8d01297113 (writer)</span><br><span class="line">2017-12-25 08:19:30.186815 I | rafthttp: started streaming with peer cbd7fa8d01297113 (writer)</span><br><span class="line">2017-12-25 08:19:30.186831 I | rafthttp: stopped streaming with peer cbd7fa8d01297113 (writer)</span><br><span class="line">2017-12-25 08:19:30.186876 I | rafthttp: started streaming with peer cbd7fa8d01297113 (stream MsgApp v2 reader)</span><br><span class="line">2017-12-25 08:19:30.187224 I | rafthttp: started streaming with peer cbd7fa8d01297113 (stream Message reader)</span><br><span class="line">2017-12-25 08:19:30.187647 I | rafthttp: stopped HTTP pipelining with peer cbd7fa8d01297113</span><br><span class="line">2017-12-25 08:19:30.187682 I | rafthttp: stopped streaming with peer cbd7fa8d01297113 (stream MsgApp v2 reader)</span><br><span class="line">2017-12-25 08:19:30.187873 I | rafthttp: stopped streaming with peer cbd7fa8d01297113 (stream Message reader)</span><br><span class="line">2017-12-25 08:19:30.187895 I | rafthttp: stopped peer cbd7fa8d01297113</span><br><span class="line">2017-12-25 08:19:30.187911 I | rafthttp: removed peer cbd7fa8d01297113</span><br><span class="line">2017-12-25 08:19:30.188034 I | etcdserver/membership: added member b2b0bca2e0cfcc19 [http://192.168.99.102:2380] to cluster f84185fa5f91bdf6</span><br><span class="line">2017-12-25 08:19:30.188059 I | rafthttp: starting peer b2b0bca2e0cfcc19...</span><br><span class="line">2017-12-25 08:19:30.188075 I | rafthttp: started HTTP pipelining with peer b2b0bca2e0cfcc19</span><br><span class="line">2017-12-25 08:19:30.188510 I | rafthttp: started peer b2b0bca2e0cfcc19</span><br><span class="line">2017-12-25 08:19:30.188533 I | rafthttp: added peer b2b0bca2e0cfcc19</span><br><span class="line">2017-12-25 08:19:30.188795 I | etcdserver/membership: removed member 773d30c9fc6640b4 from cluster f84185fa5f91bdf6</span><br><span class="line">2017-12-25 08:19:30.193643 I | rafthttp: started streaming with peer b2b0bca2e0cfcc19 (writer)</span><br><span class="line">2017-12-25 08:19:30.193730 I | rafthttp: started streaming with peer b2b0bca2e0cfcc19 (writer)</span><br><span class="line">2017-12-25 08:19:30.193797 I | rafthttp: started streaming with peer b2b0bca2e0cfcc19 (stream MsgApp v2 reader)</span><br><span class="line">2017-12-25 08:19:30.194782 I | rafthttp: started streaming with peer b2b0bca2e0cfcc19 (stream Message reader)</span><br><span class="line">2017-12-25 08:19:30.195663 I | raft: 773d30c9fc6640b4 [term: 11] received a MsgHeartbeat message with higher term from b2b0bca2e0cfcc19 [term: 12]</span><br><span class="line">2017-12-25 08:19:30.195716 I | raft: 773d30c9fc6640b4 became follower at term 12</span><br><span class="line">2017-12-25 08:19:30.195736 I | raft: raft.node: 773d30c9fc6640b4 elected leader b2b0bca2e0cfcc19 at term 12</span><br><span class="line">2017-12-25 08:19:30.196617 E | rafthttp: streaming request ignored (ID mismatch got 22b0de6ffcd98f00 want 773d30c9fc6640b4)</span><br><span class="line">2017-12-25 08:19:30.197064 E | rafthttp: streaming request ignored (ID mismatch got 22b0de6ffcd98f00 want 773d30c9fc6640b4)</span><br><span class="line">2017-12-25 08:19:30.197846 E | rafthttp: streaming request ignored (ID mismatch got 22b0de6ffcd98f00 want 773d30c9fc6640b4)</span><br><span class="line">2017-12-25 08:19:30.198242 E | rafthttp: streaming request ignored (ID mismatch got 22b0de6ffcd98f00 want 773d30c9fc6640b4)</span><br><span class="line">2017-12-25 08:19:30.201771 E | etcdserver: the member has been permanently removed from the cluster</span><br><span class="line">2017-12-25 08:19:30.202060 I | etcdserver: the data-dir used by this member must be removed.</span><br><span class="line">2017-12-25 08:19:30.202307 E | etcdserver: publish error: etcdserver: request cancelled</span><br><span class="line">2017-12-25 08:19:30.202338 I | etcdserver: aborting publish because server is stopped</span><br><span class="line">2017-12-25 08:19:30.202364 I | rafthttp: stopping peer b2b0bca2e0cfcc19...</span><br><span class="line">2017-12-25 08:19:30.202482 I | rafthttp: stopped streaming with peer b2b0bca2e0cfcc19 (writer)</span><br><span class="line">2017-12-25 08:19:30.202504 I | rafthttp: stopped streaming with peer b2b0bca2e0cfcc19 (writer)</span><br><span class="line">2017-12-25 08:19:30.204143 I | rafthttp: stopped HTTP pipelining with peer b2b0bca2e0cfcc19</span><br><span class="line">2017-12-25 08:19:30.204186 I | rafthttp: stopped streaming with peer b2b0bca2e0cfcc19 (stream MsgApp v2 reader)</span><br><span class="line">2017-12-25 08:19:30.204205 I | rafthttp: stopped streaming with peer b2b0bca2e0cfcc19 (stream Message reader)</span><br><span class="line">2017-12-25 08:19:30.204217 I | rafthttp: stopped peer b2b0bca2e0cfcc19</span><br><span class="line">2017-12-25 08:19:30.204228 I | rafthttp: stopping peer c88e2cccbb287a01...</span><br><span class="line">2017-12-25 08:19:30.204241 I | rafthttp: stopped streaming with peer c88e2cccbb287a01 (writer)</span><br><span class="line">2017-12-25 08:19:30.204255 I | rafthttp: stopped streaming with peer c88e2cccbb287a01 (writer)</span><br><span class="line">2017-12-25 08:19:30.204824 I | rafthttp: stopped HTTP pipelining with peer c88e2cccbb287a01</span><br><span class="line">2017-12-25 08:19:30.204860 I | rafthttp: stopped streaming with peer c88e2cccbb287a01 (stream MsgApp v2 reader)</span><br><span class="line">2017-12-25 08:19:30.204878 I | rafthttp: stopped streaming with peer c88e2cccbb287a01 (stream Message reader)</span><br><span class="line">2017-12-25 08:19:30.204891 I | rafthttp: stopped peer c88e2cccbb287a01</span><br></pre></td></tr></table></figure>
<p>这么长的日志，说明啥问题呢，就是说我们虽然重新执行的 etcd 创建命令，但因为读取之前配置文件的关系，etcd 会恢复之前的集群成员，但之前的集群节点已经被移除了，所以集群节点就一直处于停止状态。</p>
<p>怎么解决呢？很简单，就是将我们之前创建的<code>etcd-data</code>数据卷轴删掉，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               etcd-data</span><br><span class="line"></span><br><span class="line">$ docker volume rm etcd-data</span><br><span class="line">etcd-data</span><br></pre></td></tr></table></figure>
<p>然后，再在<code>node2</code>节点，重新执行 Docker etcd 集群配置命令（上面），会发现执行是成功的。</p>
<p>我们再执行下查看集群成员命令（v2 版本）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member list</span><br><span class="line">22b0de6ffcd98f00: name=node2 peerURLs=http://192.168.99.101:2380 clientURLs=http://192.168.99.101:2379 isLeader=false</span><br><span class="line">b2b0bca2e0cfcc19: name=node3 peerURLs=http://192.168.99.102:2380 clientURLs=http://192.168.99.102:2379 isLeader=true</span><br><span class="line">c88e2cccbb287a01: name=node1 peerURLs=http://192.168.99.100:2380 clientURLs=http://192.168.99.100:2379 isLeader=false</span><br></pre></td></tr></table></figure>
<h2 id="3-API-操作"><a href="#3-API-操作" class="headerlink" title="3. API 操作"></a>3. API 操作</h2><p>etcd REST API 被用于键值操作和集群成员操作，这边就简单说几个，详细的 API 查看附录说明。</p>
<h3 id="1-键值管理"><a href="#1-键值管理" class="headerlink" title="1. 键值管理"></a>1. 键值管理</h3><p>设置键值命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/keys/hello -XPUT -d value=&quot;hello world&quot;</span><br><span class="line">&#123;&quot;action&quot;:&quot;set&quot;,&quot;node&quot;:&#123;&quot;key&quot;:&quot;/hello&quot;,&quot;value&quot;:&quot;hello world&quot;,&quot;modifiedIndex&quot;:17,&quot;createdIndex&quot;:17&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>查看键值命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/keys/hello</span><br><span class="line">&#123;&quot;action&quot;:&quot;get&quot;,&quot;node&quot;:&#123;&quot;key&quot;:&quot;/hello&quot;,&quot;value&quot;:&quot;hello world&quot;,&quot;modifiedIndex&quot;:17,&quot;createdIndex&quot;:17&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>删除键值命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/keys/hello -XDELETE</span><br><span class="line">&#123;&quot;action&quot;:&quot;delete&quot;,&quot;node&quot;:&#123;&quot;key&quot;:&quot;/hello&quot;,&quot;modifiedIndex&quot;:19,&quot;createdIndex&quot;:17&#125;,&quot;prevNode&quot;:&#123;&quot;key&quot;:&quot;/hello&quot;,&quot;value&quot;:&quot;hello world&quot;,&quot;modifiedIndex&quot;:17,&quot;createdIndex&quot;:17&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-成员管理"><a href="#2-成员管理" class="headerlink" title="2. 成员管理"></a>2. 成员管理</h3><p>列出集群中的所有成员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/members</span><br><span class="line">&#123;&quot;members&quot;:[&#123;&quot;id&quot;:&quot;22b0de6ffcd98f00&quot;,&quot;name&quot;:&quot;node2&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.101:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.101:2379&quot;]&#125;,&#123;&quot;id&quot;:&quot;b2b0bca2e0cfcc19&quot;,&quot;name&quot;:&quot;node3&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.102:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.102:2379&quot;]&#125;,&#123;&quot;id&quot;:&quot;c88e2cccbb287a01&quot;,&quot;name&quot;:&quot;node1&quot;,&quot;peerURLs&quot;:[&quot;http://192.168.99.100:2380&quot;],&quot;clientURLs&quot;:[&quot;http://192.168.99.100:2379&quot;]&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>查看当前节点是否为管理节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/stats/leader</span><br><span class="line">&#123;&quot;leader&quot;:&quot;b2b0bca2e0cfcc19&quot;,&quot;followers&quot;:&#123;&quot;22b0de6ffcd98f00&quot;:&#123;&quot;latency&quot;:&#123;&quot;current&quot;:0.001051,&quot;average&quot;:0.0029195000000000002,&quot;standardDeviation&quot;:0.001646769458667484,&quot;minimum&quot;:0.001051,&quot;maximum&quot;:0.006367&#125;,&quot;counts&quot;:&#123;&quot;fail&quot;:0,&quot;success&quot;:10&#125;&#125;,&quot;c88e2cccbb287a01&quot;:&#123;&quot;latency&quot;:&#123;&quot;current&quot;:0.000868,&quot;average&quot;:0.0022389999999999997,&quot;standardDeviation&quot;:0.0011402923601720172,&quot;minimum&quot;:0.000868,&quot;maximum&quot;:0.004725&#125;,&quot;counts&quot;:&#123;&quot;fail&quot;:0,&quot;success&quot;:12&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>查看当前节点信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/stats/self</span><br><span class="line">&#123;&quot;name&quot;:&quot;node3&quot;,&quot;id&quot;:&quot;b2b0bca2e0cfcc19&quot;,&quot;state&quot;:&quot;StateLeader&quot;,&quot;startTime&quot;:&quot;2017-12-25T06:00:28.803429523Z&quot;,&quot;leaderInfo&quot;:&#123;&quot;leader&quot;:&quot;b2b0bca2e0cfcc19&quot;,&quot;uptime&quot;:&quot;36m45.45263851s&quot;,&quot;startTime&quot;:&quot;2017-12-25T08:13:02.103896843Z&quot;&#125;,&quot;recvAppendRequestCnt&quot;:6,&quot;sendAppendRequestCnt&quot;:22&#125;</span><br></pre></td></tr></table></figure>
<p>查看集群状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/stats/store</span><br><span class="line">&#123;&quot;getsSuccess&quot;:9,&quot;getsFail&quot;:4,&quot;setsSuccess&quot;:9,&quot;setsFail&quot;:0,&quot;deleteSuccess&quot;:3,&quot;deleteFail&quot;:0,&quot;updateSuccess&quot;:0,&quot;updateFail&quot;:0,&quot;createSuccess&quot;:7,&quot;createFail&quot;:0,&quot;compareAndSwapSuccess&quot;:0,&quot;compareAndSwapFail&quot;:0,&quot;compareAndDeleteSuccess&quot;:0,&quot;compareAndDeleteFail&quot;:0,&quot;expireCount&quot;:0,&quot;watchers&quot;:0&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以通过 API 添加和删除集群成员。</p>
<h2 id="4-API-说明和-etcdctl-命令说明"><a href="#4-API-说明和-etcdctl-命令说明" class="headerlink" title="4. API 说明和 etcdctl 命令说明"></a>4. API 说明和 etcdctl 命令说明</h2><p>etcd REST API 说明（v2 版本）：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>curl -L <a href="http://127.0.0.1:2379/version" target="_blank" rel="noopener">http://127.0.0.1:2379/version</a></td>
<td>查看版本</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a> -XPUT -d value=”Hello world”</td>
<td>添加键值</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a></td>
<td>获取键值</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a> -XPUT -d value=”Hello etcd”</td>
<td>更新键值</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/message" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/message</a> -XDELETE</td>
<td>删除键值</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/foo" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo</a> -XPUT -d value=bar -d ttl=5</td>
<td>添加 TTL 键值（过期时间）</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/foo" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo</a></td>
<td>获取 TTL 键值</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/foo" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo</a> -XPUT -d value=bar -d ttl= -d prevExist=true</td>
<td>更新 TTL 键值</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/foo?wait=true" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo?wait=true</a></td>
<td></td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/foo" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo</a> -XPUT -d value=bar</td>
<td></td>
</tr>
<tr>
<td>curl ‘<a href="http://127.0.0.1:2379/v2/keys/foo?wait=true&amp;waitIndex=7" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo?wait=true&amp;waitIndex=7</a>‘</td>
<td></td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/queue" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/queue</a> -XPOST -d value=Job1</td>
<td></td>
</tr>
<tr>
<td>curl -s ‘<a href="http://127.0.0.1:2379/v2/keys/queue?recursive=true&amp;sorted=true" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/queue?recursive=true&amp;sorted=true</a>‘</td>
<td></td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/dir" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/dir</a> -XPUT -d ttl=30 -d dir=true</td>
<td></td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/dir" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/dir</a> -XPUT -d ttl=30 -d dir=true -d prevExist=true</td>
<td></td>
</tr>
<tr>
<td>curl ‘<a href="http://127.0.0.1:2379/v2/keys/dir?wait=true" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/dir?wait=true</a>‘</td>
<td></td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/dir" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/dir</a> -XPUT -d dir=true</td>
<td>创建目录</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/foo_dir/foo" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo_dir/foo</a> -XPUT -d value=bar</td>
<td>在目录下添加键值</td>
</tr>
<tr>
<td>curl <a href="http://127.0.0.1:2379/v2/keys/?recursive=true" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/?recursive=true</a></td>
<td>获取目录下的键值</td>
</tr>
<tr>
<td>curl ‘<a href="http://127.0.0.1:2379/v2/keys/foo_dir?dir=true" target="_blank" rel="noopener">http://127.0.0.1:2379/v2/keys/foo_dir?dir=true</a>‘ -XDELETE</td>
<td>删除目录</td>
</tr>
<tr>
<td>curl <a href="http://10.0.0.10:2379/v2/members" target="_blank" rel="noopener">http://10.0.0.10:2379/v2/members</a></td>
<td>查看集群成员</td>
</tr>
<tr>
<td>curl <a href="http://10.0.0.10:2379/v2/members" target="_blank" rel="noopener">http://10.0.0.10:2379/v2/members</a> -XPOST -H “Content-Type: application/json” -d ‘{“peerURLs”:[“<a href="http://10.0.0.10:2380/" target="_blank" rel="noopener">http://10.0.0.10:2380</a>“]}’</td>
<td>添加集群成员</td>
</tr>
<tr>
<td>curl <a href="http://10.0.0.10:2379/v2/members/272e204152" target="_blank" rel="noopener">http://10.0.0.10:2379/v2/members/272e204152</a> -XDELETE</td>
<td>删除集群成员</td>
</tr>
<tr>
<td>curl <a href="http://10.0.0.10:2379/v2/members/272e204152" target="_blank" rel="noopener">http://10.0.0.10:2379/v2/members/272e204152</a> -XPUT -H “Content-Type: application/json” -d ‘{“peerURLs”:[“<a href="http://10.0.0.10:2380/" target="_blank" rel="noopener">http://10.0.0.10:2380</a>“]}’</td>
<td>更新集群成员</td>
</tr>
</tbody>
</table>
<p>更多 API 请查看：<a href="https://coreos.com/etcd/docs/latest/v2/api.html" target="_blank" rel="noopener">etcd API</a> 和 <a href="https://coreos.com/etcd/docs/latest/v2/members_api.html" target="_blank" rel="noopener">Members API</a></p>
<p>etcdctl 命令说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcdctl set key value</td>
<td>添加键值</td>
</tr>
<tr>
<td>etcdctl get key</td>
<td>获取键值</td>
</tr>
<tr>
<td>etcdctl update key value</td>
<td>更新键值</td>
</tr>
<tr>
<td>etcdctl rm key</td>
<td>删除键值</td>
</tr>
<tr>
<td>etcdctl mkdir dirname</td>
<td>添加目录（不存在的话创建）</td>
</tr>
<tr>
<td>etcdctl setdir</td>
<td>添加目录（都创建）</td>
</tr>
<tr>
<td>etcdctl updatedir</td>
<td>更新目录</td>
</tr>
<tr>
<td>etcdctl rmdir</td>
<td>删除目录</td>
</tr>
<tr>
<td>etcdctl ls</td>
<td>列出目录</td>
</tr>
<tr>
<td>etcdctl watch</td>
<td>监控键值</td>
</tr>
<tr>
<td>etcdctl exec-watch</td>
<td>监控键值（执行命令）</td>
</tr>
<tr>
<td>etcdctl list</td>
<td>查看集群成员</td>
</tr>
<tr>
<td>etcdctl member add</td>
<td>添加集群成员</td>
</tr>
<tr>
<td>etcdctl remove</td>
<td>移除集群成员</td>
</tr>
</tbody>
</table>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/xishuai/p/docker-etcd.html" target="_blank" rel="noopener">https://www.cnblogs.com/xishuai/p/docker-etcd.html</a> </li>
<li><a href="http://brewinstall.org/install-etcd-on-mac-with-brew/" target="_blank" rel="noopener">Install etcd on Mac with Brew</a></li>
<li><a href="http://blog.yiyun.pro/linux-%E5%9F%BA%E4%BA%8Edocker%E9%83%A8%E7%BD%B2etcd%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">linux 基于 docker 部署 etcd 集群</a></li>
<li><a href="http://www.cnblogs.com/zhangeamon/p/6139964.html" target="_blank" rel="noopener">Docker 搭建 etcd 集群及管理</a></li>
<li><a href="https://coolex.info/blog/481.html" target="_blank" rel="noopener">DOCKER 服务发现 - ETCD 集群</a></li>
<li><a href="https://segmentfault.com/a/1190000005645668" target="_blank" rel="noopener">docker-machine 使用 discovery 模式搭建 etcd 集群</a></li>
<li><a href="https://skyao.gitbooks.io/learning-etcd3/content/documentation/op-guide/container.html" target="_blank" rel="noopener">在容器内运行 etcd 集群</a></li>
<li><a href="https://segmentfault.com/a/1190000005649865" target="_blank" rel="noopener">etcd rest api 基本操作</a></li>
<li><a href="http://cizixs.com/2016/08/02/intro-to-etcd" target="_blank" rel="noopener">etcd 使用入门</a>(<strong>推荐</strong>)</li>
<li><a href="https://jimmysong.io/kubernetes-handbook/practice/etcd-cluster-installation.html" target="_blank" rel="noopener">创建高可用 etcd 集群</a></li>
<li><a href="https://tonydeng.github.io/2015/11/24/etcd-the-first-using/" target="_blank" rel="noopener">初试 ETCD</a>(<strong>推荐</strong>)</li>
<li><a href="https://coreos.com/etcd/docs/latest/op-guide/container.html" target="_blank" rel="noopener">Run etcd clusters inside containers</a>(<strong>官方</strong>)</li>
</ul>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
  </entry>
  <entry>
    <title>在Go框架下使用Etcd选主demo</title>
    <url>/2020/07/30/etcd/%E5%9C%A8Go%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BD%BF%E7%94%A8Etcd%E9%80%89%E4%B8%BBdemo/</url>
    <content><![CDATA[<p>在Go语言里，etcd的clientv3.concurrency包开放了选举方法concurrency.NewElection，可以直接调用。我把选举过程打印出来看，发现其内部逻辑和常规的ZK选主一样。<br>首先开启一个会话，调用election.Campaign时，在指定目录下创建一个有序id用于排队，并判断自己的id是不是最小值。如果是最小值则成为Leader。会话设置了一个TTL值，如果在TTL的时间内重新建立会话并election.Campaign，则重置TTL计时，给Leader Buff续命。超过TTL则Leader Buff消失。<br>如果自己的id不是最小值，election.Campaign会阻塞形成排队状态，此时的状态是Follower。election会watch队伍中前一个候选人的id，当它消失时则自己成为最小值，当选Leader并退出排队。如果在会话TTL的时间里重新建立会话并election.Campaign，则重置TTL计时，给Follower排队位置Buff续命。如果超过TTL，election.Campaign内部有个waitDelete方法会清除无效的排队信息，退出排队，给别人让出机会。再次election.Campaign需重新排队。</p>
<a id="more"></a>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/coreos/etcd/clientv3"</span></span><br><span class="line">	<span class="string">"github.com/coreos/etcd/clientv3/concurrency"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">"/root/elect"</span></span><br><span class="line"><span class="keyword">const</span> prop = <span class="string">"local"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	chans := [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">bool</span>&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)&#125;</span><br><span class="line">	leader := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		sec := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-time.After(<span class="number">1</span> * time.Second)</span><br><span class="line">			sec++</span><br><span class="line">			fmt.Printf(<span class="string">"========第%d秒========\n"</span>, sec)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> job(<span class="number">0</span>, chans[<span class="number">0</span>], leader)</span><br><span class="line">	<span class="keyword">go</span> job(<span class="number">1</span>, chans[<span class="number">1</span>], leader)</span><br><span class="line">	<span class="keyword">go</span> job(<span class="number">2</span>, chans[<span class="number">2</span>], leader)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		nowLeader := &lt;-leader</span><br><span class="line">		chans[nowLeader] &lt;- <span class="literal">true</span></span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		<span class="keyword">go</span> job(nowLeader, chans[nowLeader], leader)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">job</span><span class="params">(workerId <span class="keyword">int</span>, quitC <span class="keyword">chan</span> <span class="keyword">bool</span>, leader <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	endpoints := []<span class="keyword">string</span>&#123;<span class="string">"127.0.0.1:2379"</span>&#125;</span><br><span class="line">	quitA := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	quitB := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	cli, err := clientv3.New(clientv3.Config&#123;Endpoints: endpoints&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> cli.Close()</span><br><span class="line">	leaderFlag := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">go</span> campaign(cli, prefix, prop, workerId, leader, &amp;leaderFlag, quitA)</span><br><span class="line">	<span class="keyword">go</span> doCrontab(workerId, &amp;leaderFlag, quitB)</span><br><span class="line"></span><br><span class="line">	&lt;-quitC</span><br><span class="line">	fmt.Printf(<span class="string">"worker:%d 退出\n"</span>, workerId)</span><br><span class="line">	quitA &lt;- <span class="number">1</span></span><br><span class="line">	quitB &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">campaign</span><span class="params">(cli *clientv3.Client, election <span class="keyword">string</span>, prop <span class="keyword">string</span>, workerId <span class="keyword">int</span>, leader <span class="keyword">chan</span> <span class="keyword">int</span>, leaderFlag *<span class="keyword">bool</span>, quitA <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	quit := <span class="literal">false</span></span><br><span class="line">	timer := time.NewTimer(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> timer.C &#123;</span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s, err := concurrency.NewSession(cli, concurrency.WithTTL(<span class="number">5</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		e := concurrency.NewElection(s, election)</span><br><span class="line">		ctx := context.TODO()</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">"worker:%d 参加选举\n"</span>, workerId)</span><br><span class="line">		<span class="keyword">if</span> err = e.Campaign(ctx, prop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"worker:%d 选举：成功,Key:%s \n"</span>, workerId, e.Key())</span><br><span class="line">		*leaderFlag = <span class="literal">true</span></span><br><span class="line">		leader &lt;- workerId</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.Done():</span><br><span class="line">			*leaderFlag = <span class="literal">false</span></span><br><span class="line">			fmt.Println(<span class="string">"选举：超时"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-quitA:</span><br><span class="line">			s.Close()</span><br><span class="line">			quit = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"worker:%d 退出选举\n"</span>, workerId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCrontab</span><span class="params">(workerId <span class="keyword">int</span>, leaderFlag *<span class="keyword">bool</span>, quitB <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cronCnt <span class="keyword">int</span></span><br><span class="line">	ticker := time.NewTicker(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	quit := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> !quit &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			cronCnt++</span><br><span class="line">			<span class="keyword">if</span> *leaderFlag == <span class="literal">true</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"worker:%d 每1s执行定时任务: %d\n"</span>, workerId, cronCnt)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"worker:%d Follow\n"</span>, workerId)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-quitB:</span><br><span class="line">			quit = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"worker:%d 结束定时任务\n"</span>, workerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker:1 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第1秒========</span><br><span class="line">worker:1 参加选举</span><br><span class="line">worker:0 参加选举</span><br><span class="line">worker:2 参加选举</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第2秒========</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:1 选举：成功,Key:/root/elect/694d7395306acfcf </span><br><span class="line">worker:1 每1s执行定时任务: 3</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第3秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 每1s执行定时任务: 4</span><br><span class="line">========第4秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:1 退出</span><br><span class="line">worker:1 结束定时任务</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第5秒========</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-07-30T00:27:26.601+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-0ba38cd9-c8be-4d17-9262-b06184f128e2/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = Canceled desc = context canceled&quot;&#125;</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第6秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:1 参加选举</span><br><span class="line">========第7秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第8秒========</span><br><span class="line">worker:0 选举：成功,Key:/root/elect/694d7395306acfd1 </span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:0 每1s执行定时任务: 9</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第9秒========</span><br><span class="line">worker:0 每1s执行定时任务: 10</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第10秒========</span><br><span class="line">worker:0 每1s执行定时任务: 11</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 退出</span><br><span class="line">worker:0 结束定时任务</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-07-30T00:27:32.603+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-fe9fba67-e756-46a6-9471-992770da575a/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = Canceled desc = context canceled&quot;&#125;</span><br><span class="line">========第11秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第12秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:0 参加选举</span><br><span class="line">========第13秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第14秒========</span><br><span class="line">worker:2 选举：成功,Key:/root/elect/694d7395306acfd2 </span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:2 每1s执行定时任务: 15</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第15秒========</span><br><span class="line">worker:2 每1s执行定时任务: 16</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第16秒========</span><br><span class="line">worker:2 每1s执行定时任务: 17</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 退出</span><br><span class="line">worker:2 结束定时任务</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-07-30T00:27:38.606+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-b1022d31-efc4-4c89-bb86-4d919e2a9ff6/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = Canceled desc = context canceled&quot;&#125;</span><br><span class="line">========第17秒========</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第18秒========</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:2 参加选举</span><br><span class="line">========第19秒========</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第20秒========</span><br><span class="line">worker:1 选举：成功,Key:/root/elect/694d7395306acfdf </span><br><span class="line">worker:1 每1s执行定时任务: 15</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第21秒========</span><br><span class="line">worker:1 每1s执行定时任务: 16</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第22秒========</span><br><span class="line">worker:1 每1s执行定时任务: 17</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:1 退出</span><br><span class="line">worker:1 结束定时任务</span><br><span class="line">worker:2 Follow</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-07-30T00:27:44.609+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-57e503b2-8212-4eea-b92b-d2f0bca6f281/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = Canceled desc = context canceled&quot;&#125;</span><br><span class="line">========第23秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第24秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:1 参加选举</span><br><span class="line">========第25秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第26秒========</span><br><span class="line">worker:0 选举：成功,Key:/root/elect/694d7395306acfe5 </span><br><span class="line">worker:0 每1s执行定时任务: 15</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第27秒========</span><br><span class="line">worker:0 每1s执行定时任务: 16</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第28秒========</span><br><span class="line">worker:0 每1s执行定时任务: 17</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 退出</span><br><span class="line">worker:0 结束定时任务</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-07-30T00:27:50.616+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-c04606c3-6323-4351-a40c-0b283bdb43a5/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = Canceled desc = context canceled&quot;&#125;</span><br><span class="line">========第29秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第30秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 参加选举</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第31秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第32秒========</span><br><span class="line">worker:2 选举：成功,Key:/root/elect/694d7395306acfeb </span><br><span class="line">worker:2 每1s执行定时任务: 15</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第33秒========</span><br><span class="line">worker:2 每1s执行定时任务: 16</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第34秒========</span><br><span class="line">worker:2 每1s执行定时任务: 17</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 退出</span><br><span class="line">worker:2 结束定时任务</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-07-30T00:27:56.621+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-c91918eb-7478-4d18-bef1-39fd076e3cf1/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = Canceled desc = context canceled&quot;&#125;</span><br><span class="line">========第35秒========</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第36秒========</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:2 参加选举</span><br><span class="line">========第37秒========</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">========第38秒========</span><br><span class="line">worker:1 选举：成功,Key:/root/elect/694d7395306acff1 </span><br><span class="line">worker:1 每1s执行定时任务: 15</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第39秒========</span><br><span class="line">worker:1 每1s执行定时任务: 16</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第40秒========</span><br><span class="line">worker:1 每1s执行定时任务: 17</span><br><span class="line">worker:1 退出</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 结束定时任务</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2020-07-30T00:28:02.623+0800&quot;,&quot;caller&quot;:&quot;clientv3/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;endpoint://client-0e8ec9ff-5258-4cc9-9314-29e1febb9b16/127.0.0.1:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = Canceled desc = context canceled&quot;&#125;</span><br><span class="line">========第41秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">========第42秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:1 参加选举</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第43秒========</span><br><span class="line">worker:0 Follow</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第44秒========</span><br><span class="line">worker:0 选举：成功,Key:/root/elect/694d7395306acff7 </span><br><span class="line">worker:0 每1s执行定时任务: 15</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第45秒========</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:0 每1s执行定时任务: 16</span><br><span class="line">worker:1 Follow</span><br><span class="line">========第46秒========</span><br><span class="line">worker:0 每1s执行定时任务: 17</span><br><span class="line">worker:2 Follow</span><br><span class="line">worker:0 退出</span><br><span class="line">worker:1 Follow</span><br><span class="line">worker:0 结束定时任务</span><br></pre></td></tr></table></figure>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>Raft算法及etcd/raft的实现思路借鉴<br><a href="http://atomicer.cn/2019/05/17/etcd-raft%E4%B8%ADraft%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%8F%82%E8%80%83/" target="_blank" rel="noopener">http://atomicer.cn/2019/05/17/etcd-raft%E4%B8%ADraft%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%8F%82%E8%80%83/</a></p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>go</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd 可视化</title>
    <url>/2019/05/07/etcd/etcd-%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p><code>wget https://github.com/evildecay/etcdkeeper/releases/download/v0.7.4/etcdkeeper-v0.7.4-linux_x86_64.zip</code></p>
<p>在etcd集群的某台机器上，解压后执行命令</p>
<p><code>./etcdkeeper -p 8001</code></p>
<p>通过http访问这个端口，可以可视化操作etcd</p>
<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://github.com/evildecay/etcdkeeper/releases" target="_blank" rel="noopener">https://github.com/evildecay/etcdkeeper/releases</a> </p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
  </entry>
  <entry>
    <title>jackcooper 简书一些文章</title>
    <url>/2019/05/10/%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3/jackcooper-%E7%AE%80%E4%B9%A6%E4%B8%80%E4%BA%9B%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">分库分表需要考虑的问题及方案</a><br><a href="https://www.jianshu.com/p/8d0d2c86ff50" target="_blank" rel="noopener">idea快捷键</a><br><a href="https://www.jianshu.com/p/e7fb32bd255c" target="_blank" rel="noopener">java8 中常用的新方法</a><br><a href="https://www.jianshu.com/p/b2961d9a9e0a" target="_blank" rel="noopener">设计模式简单总结</a></p>
<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.jianshu.com/p/9fb79fb0b5b1" target="_blank" rel="noopener">各大互联网公司架构汇总</a></p>
<p><a href="https://www.jianshu.com/p/5920a93a451f" target="_blank" rel="noopener">SpringBoot学习目录</a></p>
<p><a href="https://www.jianshu.com/p/c689ea6c2905" target="_blank" rel="noopener">Java技术栈2017年度精选干货总结</a></p>
<p><a href="https://www.jianshu.com/p/aaa700a131f0" target="_blank" rel="noopener">后端架构师技术图谱</a></p>
<p><a href="https://www.jianshu.com/p/061a78a94ec4" target="_blank" rel="noopener">神奇的mybatis分页插件</a></p>
<p><a href="https://www.jianshu.com/p/4b95162fa09e" target="_blank" rel="noopener">Java后端常用的开源项目推荐</a></p>
]]></content>
      <categories>
        <category>他山之石</category>
      </categories>
  </entry>
  <entry>
    <title>分库分表需要考虑的问题及方案</title>
    <url>/2019/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<ol>
<li><p>事务问题</p>
</li>
<li><p>跨节点Join的问题</p>
</li>
<li><p>跨节点的count,order by,group by以及聚合函数问题</p>
</li>
<li><p>数据迁移，容量规划，扩容等问题</p>
</li>
<li><p>事务</p>
</li>
<li><p>ID问题</p>
</li>
<li><p>跨分片的排序分页</p>
</li>
<li><p>分库策略</p>
</li>
<li><p>分库数量</p>
</li>
<li><p>路由透明</p>
</li>
<li><p>使用框架还是自主研发</p>
</li>
</ol>
<a id="more"></a>
<h1 id="分库分表的基本思想"><a href="#分库分表的基本思想" class="headerlink" title="分库分表的基本思想"></a><a href="http://blog.csdn.net/bluishglc/article/details/6161475" target="_blank" rel="noopener">分库分表的基本思想</a></h1><blockquote>
<p>Sharding的基本思想就要把一个<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。不太严格的讲，对于海量数据的数据库，如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个server上。如果表并不多，但每张表的数据非常多，这时候适合水平切分，即把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上。当然，现实中更多是这两种情况混杂在一起，这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列。</p>
</blockquote>
<blockquote>
<p>需要特别说明的是：当同时进行垂直和水平切分时，切分策略会发生一些微妙的变化。比如：在只考虑垂直切分的时候，被划分到一起的表之间可以保持任意的关联关系，因此你可以按“功能模块”划分表格，但是一旦引入水平切分之后，表间关联关系就会受到很大的制约，通常只能允许一个主表（以该表ID进行散列的表）和其多个次表之间保留关联关系，也就是说：当同时进行垂直和水平切分时，在垂直方向上的切分将不再以“功能模块”进行划分，而是需要更加细粒度的垂直切分，而这个粒度与领域驱动设计中的“聚合”概念不谋而合，甚至可以说是完全一致，每个shard的主表正是一个聚合中的聚合根！这样切分下来你会发现数据库分被切分地过于分散了（shard的数量会比较多，但是shard里的表却不多），为了避免管理过多的数据源，充分利用每一个数据库服务器的资源，可以考虑将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个shard放到同一个数据源里，每个shard依然是独立的，它们有各自的主表，并使用各自主表ID进行散列，不同的只是它们的散列取模（即节点数量）必需是一致的.</p>
</blockquote>
<h2 id="常用的分库分表中间件"><a href="#常用的分库分表中间件" class="headerlink" title="常用的分库分表中间件"></a>常用的分库分表中间件</h2><h3 id="简单易用的组件："><a href="#简单易用的组件：" class="headerlink" title="简单易用的组件："></a>简单易用的组件：</h3><ul>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="noopener">当当sharding-jdbc</a></li>
<li><a href="https://github.com/baihui212/tsharding" target="_blank" rel="noopener">蘑菇街TSharding</a></li>
</ul>
<h3 id="强悍重量级的中间件："><a href="#强悍重量级的中间件：" class="headerlink" title="强悍重量级的中间件："></a>强悍重量级的中间件：</h3><ul>
<li><a href="https://github.com/go-pg/sharding" target="_blank" rel="noopener">sharding</a></li>
<li><a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">TDDL Smart Client的方式（淘宝）</a></li>
<li><a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">Atlas(Qihoo 360)</a></li>
<li><a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">alibaba.cobar(是阿里巴巴（B2B）部门开发)</a></li>
<li><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">MyCAT（基于阿里开源的Cobar产品而研发）</a></li>
<li><a href="https://github.com/58code/Oceanus" target="_blank" rel="noopener">Oceanus(58同城数据库中间件)</a></li>
<li><a href="http://www.cnblogs.com/youge-OneSQL/articles/4208583.html" target="_blank" rel="noopener">OneProxy(支付宝首席架构师楼方鑫开发)</a></li>
<li><a href="https://github.com/youtube/vitess" target="_blank" rel="noopener">vitess（谷歌开发的数据库中间件）</a></li>
</ul>
<h2 id="分库分表需要解决的问题"><a href="#分库分表需要解决的问题" class="headerlink" title="分库分表需要解决的问题"></a>分库分表需要解决的问题</h2><p> 1、事务问题</p>
<blockquote>
<p>解决事务问题目前有两种可行的方案：分布式事务和通过应用程序与数据库共同控制实现事务下面对两套方案进行一个简单的对比。</p>
</blockquote>
<ul>
<li>方案一：使用分布式事务<ul>
<li><ul>
<li>优点：交由数据库管理，简单有效</li>
</ul>
</li>
<li>缺点：性能代价高，特别是shard越来越多时</li>
</ul>
</li>
<li>方案二：由应用程序和数据库共同控制<ul>
<li>原理：将一个跨多个数据库的分布式事务分拆成多个仅处 于单个数据库上面的小事务，并通过应用程序来总控 各个小事务。</li>
<li>优点：性能上有优势</li>
<li>缺点：需要应用程序在事务控制上做灵活设计。如果使用 了spring的事务管理，改动起来会面临一定的困难。</li>
</ul>
</li>
</ul>
<h3 id="2、跨节点Join的问题"><a href="#2、跨节点Join的问题" class="headerlink" title="2、跨节点Join的问题"></a>2、跨节点Join的问题</h3><blockquote>
<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。</p>
</blockquote>
<h3 id="3、跨节点的count-order-by-group-by以及聚合函数问题"><a href="#3、跨节点的count-order-by-group-by以及聚合函数问题" class="headerlink" title="3、跨节点的count,order by,group by以及聚合函数问题"></a>3、跨节点的count,order by,group by以及聚合函数问题</h3><blockquote>
<p>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
</blockquote>
<h3 id="4、数据迁移，容量规划，扩容等问题"><a href="#4、数据迁移，容量规划，扩容等问题" class="headerlink" title="4、数据迁移，容量规划，扩容等问题"></a>4、数据迁移，容量规划，扩容等问题</h3><blockquote>
<p>来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了<strong>行级别的数据迁移</strong>，但是依然需要进行<strong>表级别的迁移</strong>，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p>
</blockquote>
<h3 id="5、事务"><a href="#5、事务" class="headerlink" title="5、事务"></a>5、事务</h3><blockquote>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考： [关于分布式事务、两阶段提交、一阶段提交、Best Efforts 1PC模式和事务补偿机制的研究](http://blog.csdn.net/bluishglc/article/details/7612811)</span><br></pre></td></tr></table></figure>
<ul>
<li>优点<ul>
<li>基于两阶段提交，最大限度地保证了跨数据库操作的“原子性”，是分布式系统下最严格的事务实现方式。</li>
<li>实现简单，工作量小。由于多数应用服务器以及一些独立的分布式事务协调器做了大量的封装工作，使得项目中引入分布式事务的难度和工作量基本上可以忽略不计。</li>
</ul>
</li>
<li>缺点<ul>
<li>系统“水平”伸缩的死敌。基于两阶段提交的分布式事务在提交事务时需要在多个节点之间进行协调,最大限度地推后了提交事务的时间点，客观上延长了事务的执行时间，这会导致事务在访问共享资源时发生冲突和死锁的概率增高，随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平伸缩的”枷锁”， 这是很多Sharding系统不采用分布式事务的主要原因。</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="基于Best-Efforts-1PC模式的事务"><a href="#基于Best-Efforts-1PC模式的事务" class="headerlink" title="基于Best Efforts 1PC模式的事务"></a>基于Best Efforts 1PC模式的事务</h4></blockquote>
<p>参考<a href="https://github.com/SpringSource/spring-data-graph/blob/master/spring-data-neo4j/src/main/java/org/springframework/data/neo4j/transaction/ChainedTransactionManager.java" target="_blank" rel="noopener">spring-data-neo4j</a>的实现。鉴于Best Efforts 1PC模式的性能优势，以及相对简单的实现方式，它被大多数的sharding框架和项目采用</p>
<blockquote>
<h4 id="事务补偿（幂等值）"><a href="#事务补偿（幂等值）" class="headerlink" title="事务补偿（幂等值）"></a>事务补偿（幂等值）</h4></blockquote>
<p>对于那些对性能要求很高，但对一致性要求并不高的系统，往往并不苛求系统的实时一致性，只要在一个允许的时间周期内达到最终一致性即可，这使得事务补偿机制成为一种可行的方案。事务补偿机制最初被提出是在“长事务”的处理中，但是对于分布式系统确保一致性也有很好的参考意义。笼统地讲，与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查并补救的措施，它只期望在一个容许时间周期内得到最终一致的结果就可以了。事务补偿的实现与系统业务紧密相关，并没有一种标准的处理方式。一些常见的实现方式有：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步，等等。</p>
<h2 id="6、ID问题"><a href="#6、ID问题" class="headerlink" title="6、ID问题"></a>6、ID问题</h2><blockquote>
<p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由.<br>一些常见的主键生成策略</p>
</blockquote>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><blockquote>
<p>使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p>
</blockquote>
<h3 id="结合数据库维护一个Sequence表"><a href="#结合数据库维护一个Sequence表" class="headerlink" title="结合数据库维护一个Sequence表"></a>结合数据库维护一个Sequence表</h3><blockquote>
<p>此方案的思路也很简单，在数据库中建立一个Sequence表，表的结构类似于：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `SEQUENCE` (  </span><br><span class="line">    `table_name` varchar(18) NOT NULL,  </span><br><span class="line">    `nextid` bigint(20) NOT NULL,  </span><br><span class="line">    PRIMARY KEY (`table_name`)  </span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,并将nextid的值加1后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。有人提出使用Master-Slave进行主从同步，但这也只能解决单点问题，并不能解决读写比为1:1的访问压力问题。</p>
</blockquote>
<h3 id="Twitter的分布式自增ID算法Snowflake"><a href="#Twitter的分布式自增ID算法Snowflake" class="headerlink" title="Twitter的分布式自增ID算法Snowflake"></a><a href="http://blog.sina.com.cn/s/blog_6b7c2e660102vbi2.html" target="_blank" rel="noopener">Twitter的分布式自增ID算法Snowflake</a></h3><blockquote>
<p>在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。<br>* 10—0000000000 0000000000 0000000000 0000000000 0 — 00000 —00000 —000000000000<br>在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。</p>
</blockquote>
<blockquote>
<p>这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</p>
</blockquote>
<h2 id="7、跨分片的排序分页"><a href="#7、跨分片的排序分页" class="headerlink" title="7、跨分片的排序分页"></a>7、跨分片的排序分页</h2><blockquote>
<p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3710706-925381b9a478c8df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第10页数据，情况又将变得复杂很多，如下图所示：</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3710706-9a7cfbdb95bb9b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前10条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前N页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。</p>
<blockquote>
<p>那如何解决分库情况下的分页问题呢？有以下几种办法：</p>
</blockquote>
<blockquote>
<p>如果是在前台应用提供分页，则限定用户只能看前面n页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</p>
</blockquote>
<blockquote>
<p>如果是后台批处理任务要求分批获取数据，则可以加大page size，比如每次获取5000条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</p>
</blockquote>
<blockquote>
<p>分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</p>
</blockquote>
<h2 id="8、分库策略"><a href="#8、分库策略" class="headerlink" title="8、分库策略"></a>8、分库策略</h2><blockquote>
<p>分库维度确定后，如何把记录分到各个库里呢?<br>一般有两种方式：</p>
</blockquote>
<ul>
<li>根据数值范围，比如用户Id为1-9999的记录分到第一个库，10000-20000的分到第二个库，以此类推。</li>
<li>根据数值取模，比如用户Id mod n，余数为0的记录放到第一个库，余数为1的放到第二个库，以此类推。</li>
</ul>
<blockquote>
<p>优劣比较：<br>评价指标按照范围分库按照Mod分库<br>库数量前期数目比较小，可以随用户/业务按需增长前期即根据mode因子确定库数量，数目一般比较大<br>访问性能前期库数量小，全库查询消耗资源少，单库查询性能略差前期库数量大，全库查询消耗资源多，单库查询性能略好<br>调整库数量比较容易，一般只需为新用户增加库，老库拆分也只影响单个库困难，改变mod因子导致数据在所有库之间迁移<br>数据热点新旧用户购物频率有差异，有数据热点问题新旧用户均匀到分布到各个库，无热点<br>实践中，为了处理简单，选择mod分库的比较多。同时二次分库时，为了数据迁移方便，一般是按倍数增加，比如初始4个库，二次分裂为8个，再16个。这样对于某个库的数据，一半数据移到新库，剩余不动，对比每次只增加一个库，所有数据都要大规模变动。<br>补充下，mod分库一般每个库记录数比较均匀，但也有些数据库，存在超级Id，这些Id的记录远远超过其他Id，比如在广告场景下，某个大广告主的广告数可能占总体很大比例。如果按照广告主Id取模分库，某些库的记录数会特别多，对于这些超级Id，需要提供单独库来存储记录。</p>
</blockquote>
<h2 id="9、分库数量"><a href="#9、分库数量" class="headerlink" title="9、分库数量"></a>9、分库数量</h2><blockquote>
<p>分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过5000万条记录，Oracle单库超过1亿条记录，DB压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。</p>
</blockquote>
<blockquote>
<p>在满足上述前提下，如果分库数量少，达不到分散存储和减轻DB性能压力的目的；如果分库的数量多，好处是每个库记录少，单库访问性能好，但对于跨多个库的访问，应用程序需要访问多个库，如果是并发模式，要消耗宝贵的线程资源；如果是串行模式，执行时间会急剧增加。</p>
</blockquote>
<blockquote>
<p>最后分库数量还直接影响硬件的投入，一般每个分库跑在单独物理机上，多一个库意味多一台设备。所以具体分多少个库，要综合评估，一般初次分库建议分4-8个库。</p>
</blockquote>
<h2 id="10、路由透明"><a href="#10、路由透明" class="headerlink" title="10、路由透明"></a>10、路由透明</h2><blockquote>
<p>分库从某种意义上来说，意味着DB schema改变了，必然影响应用，但这种改变和业务无关，所以要尽量保证分库对应用代码透明，分库逻辑尽量在数据访问层处理。当然完全做到这一点很困难，具体哪些应该由DAL负责，哪些由应用负责，这里有一些建议：</p>
</blockquote>
<blockquote>
<p>对于单库访问，比如查询条件指定用户Id，则该SQL只需访问特定库。此时应该由DAL层自动路由到特定库，当库二次分裂时，也只要修改mod 因子，应用代码不受影响。</p>
</blockquote>
<blockquote>
<p>对于简单的多库查询，DAL负责汇总各个数据库返回的记录，此时仍对上层应用透明。</p>
</blockquote>
<h2 id="11、使用框架还是自主研发"><a href="#11、使用框架还是自主研发" class="headerlink" title="11、使用框架还是自主研发"></a>11、使用框架还是自主研发</h2><blockquote>
<p>目前市面上的分库分表中间件相对较多，其中基于代理方式的有MySQL Proxy和Amoeba，基于Hibernate框架的是Hibernate Shards，基于jdbc的有<a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="noopener">当当sharding-jdbc</a>，基于mybatis的类似maven插件式的有蘑菇街的<a href="https://github.com/baihui212/tsharding" target="_blank" rel="noopener">蘑菇街TSharding</a>，通过重写spring的ibatis template类是Cobar Client，这些框架各有各的优势与短板，架构师可以在深入调研之后结合项目的实际情况进行选择，但是总的来说，我个人对于框架的选择是持谨慎态度的。一方面多数框架缺乏成功案例的验证，其成熟性与稳定性值得怀疑。另一方面，一些从成功商业产品开源出框架（如阿里和淘宝的一些开源项目）是否适合你的项目是需要架构师深入调研分析的。当然，最终的选择一定是基于项目特点、团队状况、技术门槛和学习成本等综合因素考量确定的。</p>
</blockquote>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">https://www.jianshu.com/p/32b3e91aa22c</a> </p>
]]></content>
  </entry>
  <entry>
    <title>从零开始学架构-听书笔记</title>
    <url>/2020/08/09/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84-%E5%90%AC%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>理解架构复杂度来源</li>
<li>架构设计三原则</li>
</ul>
<a id="more"></a>
<h2 id="复杂度四大来源"><a href="#复杂度四大来源" class="headerlink" title="复杂度四大来源"></a>复杂度四大来源</h2><ul>
<li><p>高性能<br>单机复杂度：批处理-&gt;进程-&gt;SMP（现在最流行的对称多处理器架构）<br>集群复杂度：任务分配、任务分解</p>
</li>
<li><p>高可用<br>计算高可用、存储高可用</p>
</li>
<li><p>可扩展性<br>正确预测变化：分清主次，头脑风暴<br>完美封装变化：剥离变化层和稳定层</p>
</li>
<li><p>低成本、安全、规模</p>
</li>
</ul>
<h2 id="架构设计三原则"><a href="#架构设计三原则" class="headerlink" title="架构设计三原则"></a>架构设计三原则</h2><ul>
<li><p>合适优于先进<br>先进技术可能有缺陷未被发现<br>对不熟悉的技术把控不足</p>
</li>
<li><p>简单优于复杂<br>对于集成电路，越复杂可能越好，软件领域却不是这样。因为电路设计好之后基本不会变，而软件就是不断迭代变化，越简单越容易实现和维护。<br>实在不得已要做得复杂时，可以参考集成电路模块化，以模块为单元进行更替。</p>
</li>
<li><p>可演化优于一步到位</p>
</li>
</ul>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>极客时间 - 从零开始学架构</p>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title>一些杂碎知识</title>
    <url>/2019/04/11/%E6%9D%82%E8%B4%A7%E6%9F%9C/%E4%B8%80%E4%BA%9B%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>日常收集</p>
<a id="more"></a>
<p>架构图的画法——阿里巴巴中间件<br><a href="https://mp.weixin.qq.com/s/MZwTb3nINuRsOKy0mLNa_A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MZwTb3nINuRsOKy0mLNa_A</a></p>
<p>新型查询框架GraphQL，类似REST<br><a href="https://mp.weixin.qq.com/s/Cx3xxPbqhb_Zx7mjyS3Tyg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Cx3xxPbqhb_Zx7mjyS3Tyg</a></p>
<p>一个比较中意的Hexo<br><a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">https://github.com/pinggod/hexo-theme-apollo</a></p>
<p>一个有意思的技术博客<br><a href="http://andrewliu.in/archives/" target="_blank" rel="noopener">http://andrewliu.in/archives/</a></p>
]]></content>
      <categories>
        <category>杂货柜</category>
      </categories>
  </entry>
  <entry>
    <title>博客安家</title>
    <url>/2019/04/09/%E6%9D%82%E8%B4%A7%E6%9F%9C/%E5%8D%9A%E5%AE%A2%E5%AE%89%E5%AE%B6/</url>
    <content><![CDATA[<p>搭个博客来记录技术日志和生活</p>
<a id="more"></a>
<p>主要参考 小茗同学 的帖子<br><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93</a></p>
]]></content>
      <categories>
        <category>杂货柜</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（一）</title>
    <url>/2019/05/07/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>一、工厂模式</p>
<p>二、抽象工厂模式</p>
<p>三、单例模式</p>
<p>四、建造者模式<br><a id="more"></a></p>
<h4 id="一、工厂模式：隐藏对象创建逻辑，并使用共同接口指向新创建的对象"><a href="#一、工厂模式：隐藏对象创建逻辑，并使用共同接口指向新创建的对象" class="headerlink" title="一、工厂模式：隐藏对象创建逻辑，并使用共同接口指向新创建的对象"></a>一、工厂模式：隐藏对象创建逻辑，并使用共同接口指向新创建的对象</h4><p>例如实现接口Shape，有Circle，Rectangle等。各自实现Shape里的draw方法。把new出来的各种”Shape”放到Shape里，调用shape.draw()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shapeFactory.getShape(&quot;CIRCLE&quot;).draw();</span><br></pre></td></tr></table></figure>
<h4 id="二、抽象工厂模式：把工厂也当成一个需要创建的对象"><a href="#二、抽象工厂模式：把工厂也当成一个需要创建的对象" class="headerlink" title="二、抽象工厂模式：把工厂也当成一个需要创建的对象"></a>二、抽象工厂模式：把工厂也当成一个需要创建的对象</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line">colorFactory.getColor(&quot;RED&quot;).fill();</span><br></pre></td></tr></table></figure>
<h4 id="三、单例模式：分为懒汉式（用到才创建，省内存，需要考虑线程安全）、饿汉式（类加载就创建，非lazy-loading）"><a href="#三、单例模式：分为懒汉式（用到才创建，省内存，需要考虑线程安全）、饿汉式（类加载就创建，非lazy-loading）" class="headerlink" title="三、单例模式：分为懒汉式（用到才创建，省内存，需要考虑线程安全）、饿汉式（类加载就创建，非lazy loading）"></a>三、单例模式：分为懒汉式（用到才创建，省内存，需要考虑线程安全）、饿汉式（类加载就创建，非lazy loading）</h4><p><strong>懒汉式，线程安全</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>饿汉式（推荐）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>静态内部类，资源利用率高，第一次加载不够快</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、建造者模式：对于内部复杂的结构，单独设置一个类来完成构建"><a href="#四、建造者模式：对于内部复杂的结构，单独设置一个类来完成构建" class="headerlink" title="四、建造者模式：对于内部复杂的结构，单独设置一个类来完成构建"></a>四、建造者模式：对于内部复杂的结构，单独设置一个类来完成构建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">        <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MealBuilder mealBuilder = <span class="keyword">new</span> MealBuilder();</span><br><span class="line">    Meal vegMeal = mealBuilder.prepareVegMeal();</span><br><span class="line">    System.out.println(<span class="string">"Veg Meal"</span>);</span><br><span class="line">    vegMeal.showItems();</span><br><span class="line">    System.out.println(<span class="string">"Total Cost: "</span> +vegMeal.getCost());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>  <a href="http://www.cnblogs.com/damsoft/p/6105122.html" target="_blank" rel="noopener">http://www.cnblogs.com/damsoft/p/6105122.html</a></p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>idea常用快捷键</title>
    <url>/2019/05/10/%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD/idea-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li><code>Ctrl+Alt+[</code>　　跳转到下一个项目</li>
<li><code>Ctrl+Alt+]</code>　　跳转到上一个项目</li>
</ul>
<a id="more"></a>
<h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><ul>
<li><code>Ctrl＋Alt+L</code></li>
</ul>
<h2 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a>抽取</h2><ul>
<li><code>Ctrl+Alt+v</code> 方法内抽取变量</li>
<li><code>Ctrl+Alt+C</code> 抽取静态变量</li>
<li><code>Ctrl+Alt+F</code> 抽取成员变量</li>
<li><code>Ctrl+Alt+P</code>　抽取方法参数</li>
<li><code>Ctrl+Alt+M</code> 抽取方法</li>
</ul>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul>
<li><code>Shift+F6</code> 重命名（所有的文件，类名，函数名，属性名都可以重命名）</li>
<li><code>Ctrl+F6</code> 重构函数（当你需要重构方法时，无论是增加参数，修改返回值，还是更改函数实现，只需要Ctrl+F6，就可以把所有用到此函数的地方一起重构，界面如下）</li>
</ul>
<h2 id="视图查看"><a href="#视图查看" class="headerlink" title="视图查看"></a>视图查看</h2><ul>
<li><code>Ctrl+F12</code> 查看file，method结构图、类继承机构图</li>
<li><code>Ctrl+shift+Alt+U</code> 查看maven依赖，类图</li>
<li><code>Ctrl＋Alt+H</code> 查看方法调用层次</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>1、项目之间跳转</p>
<ul>
<li><code>Ctrl+Alt+[</code>　　跳转到下一个项目</li>
<li><code>Ctrl+Alt+]</code>　　跳转到上一个项目</li>
</ul>
<p>2、文件之间跳转</p>
<ul>
<li><code>Ctrl+E</code>　　 定位到最近浏览过的文件</li>
<li><code>Ctrl+Shift+E</code>　　最近更改的文件</li>
<li><code>Shift+Click</code>　　可以关闭文件</li>
</ul>
<p>3.位置的跳转</p>
<ul>
<li><code>Ctrl+Shift+Backspace</code>　　 跳转上一次修改的地方</li>
<li><code>Ctrl+Alt+B</code>　　跳转到方法实现处</li>
<li><code>Ctrl+Shift+左箭头</code>　　上一个浏览的地方</li>
<li><code>Ctrl+Shift+右箭头</code>　　下一个浏览的地方</li>
</ul>
<p>4.其他的跳转</p>
<ul>
<li><code>Ctrl+H</code>　　显示类结构图（类的继承层次）</li>
<li><code>Ctrl+Q</code>　　显示注释文档</li>
<li><code>Alt+1</code>　　快速打开或隐藏工程面板</li>
<li><code>Alt+left/right</code>　　切换代码视图</li>
<li><code>F2 或 Shift+F2</code>　　高亮错误或警告快速定位</li>
<li><code>Tab</code>　　代码标签输入完成后，按 Tab，生成代码</li>
<li><code>Ctrl+Shift+F7</code>　　高亮显示所有该文本，按 Esc 高亮消失</li>
</ul>
<p>5.搜索</p>
<ul>
<li><code>Ctrl＋N</code>　　快速搜索类</li>
<li><code>Ctrl＋Shift＋N</code>　　快速搜索文件</li>
<li><code>Ctrl＋Alt+Shift＋N</code>　　快速搜索函数</li>
<li><code>Ctrl+Shift+F</code>　　快速搜索字符串</li>
<li><code>Alt+F1</code>　　查找代码所在位置</li>
<li><code>Alt+F3</code>　　逐个往下查找相同文本，并高亮显示</li>
</ul>
<p>6.光标移动和选中</p>
<ul>
<li><code>Ctrl＋Alt+Shift＋J</code> 选中所有相应的目标</li>
<li><code>Alt+Up/Down</code>　　在方法间快速移动定位</li>
<li><code>Ctrl+Shift+Up/Down</code>　　向上/下移动语句</li>
<li><code>Ctrl+Up/Down</code>　　光标中转到第一行或最后一行下</li>
<li><code>Ctrl+B/Ctrl+Click</code>　　快速打开光标处的类或方法（跳转到定义处）</li>
</ul>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a href="https://www.jianshu.com/p/8d0d2c86ff50" target="_blank" rel="noopener">https://www.jianshu.com/p/8d0d2c86ff50</a> </p>
]]></content>
      <categories>
        <category>研发效能</category>
      </categories>
  </entry>
  <entry>
    <title>一致性哈希</title>
    <url>/2020/07/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<p>一致性哈希主要解决的问题是，数据分片之后，简单取模方式在增删节点时会造成所有节点不可用。经过一致性哈希，可以将故障限制在局部范围内。比如redis集群就是一个使用一致性哈希的场景（虽然redis用的不是一致性哈希）。<br><a id="more"></a></p>
<p>题外话：</p>
<blockquote>
<p>可以认为vitess的分片方式也是一致性哈希。vitess也是将键空间映射到2^32 的范围，将键空间分割，根据分片键的值决定将数据存放到对应分片中。<br>和一致性哈希不同的是，vitess每个分片可以是均匀的，新加节点可以把现有的单个分片拆得更细，而不会影响到其他分片</p>
</blockquote>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>一致性hash算法释义<br><a href="https://www.cnblogs.com/haippy/archive/2011/12/10/2282943.html" target="_blank" rel="noopener">https://www.cnblogs.com/haippy/archive/2011/12/10/2282943.html</a></p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>学习数据分析</title>
    <url>/2020/08/15/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>从专业角度看看数据可视化<br><a id="more"></a></p>
<h4 id="数据的恰当表达很重要"><a href="#数据的恰当表达很重要" class="headerlink" title="数据的恰当表达很重要"></a>数据的恰当表达很重要</h4><p>合适的表达有助于推导出结论，表达思维</p>
<p>理解图表自有的内在逻辑</p>
<ul>
<li>柱状图<ul>
<li>直观展示数据变化</li>
</ul>
</li>
<li>关系图</li>
<li>空间图表<ul>
<li>按地理位置分布</li>
</ul>
</li>
<li>散点图<ul>
<li>多个维度交叉查看</li>
</ul>
</li>
</ul>
<h4 id="数据表达的形式和意义"><a href="#数据表达的形式和意义" class="headerlink" title="数据表达的形式和意义"></a>数据表达的形式和意义</h4><p>分析图表、动态交互、商业智能</p>
<ul>
<li>分析图表<ul>
<li>多维度<ul>
<li>热力图</li>
<li>K线图</li>
<li>散点图+x/y轴直方图表示概率分布</li>
<li>矩阵形式的单维度表</li>
<li>树状图</li>
</ul>
</li>
<li>空间图表</li>
<li>关系图表<ul>
<li>捋清关系</li>
</ul>
</li>
</ul>
</li>
<li>动态交互<ul>
<li>Echarts<ul>
<li>显示某个点的值以及横纵坐标</li>
<li>查看不同时间段内的数据</li>
<li>选择查看的类目</li>
</ul>
</li>
</ul>
</li>
<li>商业智能<ul>
<li>商务报表。数据分析固化，</li>
<li>BDP（线上）、Tableau（离线，收费）、微软PowerBI</li>
</ul>
</li>
</ul>
<p>数据分析课程更重在静/动态图表表达的逻辑，以及怎样帮助我们出结论。</p>
<h4 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h4><p>Matplotlib、geoplotlib、Seaborn、Bokeh、Gephi</p>
<h4 id="题外话："><a href="#题外话：" class="headerlink" title="题外话："></a>题外话：</h4><p>课程主要目的是培养数据的逻辑思维，技能其次。<br>不用规划太长的道路，可以边走边看业务场景和个人发展路径。<br>从数据分析师、建模分析师到数据科学家有很长的路要走。除了做技术，应该上升到更宏观的层次，对个人发展比较好。<br>数据库、数据分析、数据爬虫是三个领域。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>网易数据分析</p>
]]></content>
  </entry>
  <entry>
    <title>JDK并发包</title>
    <url>/2019/04/26/Java/%E9%AB%98%E5%B9%B6%E5%8F%91/JDK%E5%B9%B6%E5%8F%91%E5%8C%85/</url>
    <content><![CDATA[<h3 id="JDK并发包简介"><a href="#JDK并发包简介" class="headerlink" title="JDK并发包简介"></a>JDK并发包简介</h3><p>[TOC]</p>
<h2 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h2><h3 id="1-synchronized扩展：重入锁-ReentrantLock"><a href="#1-synchronized扩展：重入锁-ReentrantLock" class="headerlink" title="1. synchronized扩展：重入锁 ReentrantLock"></a>1. synchronized扩展：重入锁 ReentrantLock</h3><p>必须手动指定加解锁，提高逻辑控制灵活性</p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>lock.lockInterruptibly()可被Thread.interrupt()中断</p>
<h4 id="可设置超时"><a href="#可设置超时" class="headerlink" title="可设置超时"></a>可设置超时</h4><p>lock.tryLock(5, TimeUnit.SECONDS) 超时返回false</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>new ReentrantLock(true) 可生成公平锁</p>
<h3 id="2-信号量-Semaphore"><a href="#2-信号量-Semaphore" class="headerlink" title="2. 信号量 Semaphore"></a>2. 信号量 Semaphore</h3><p>控制同时执行的线程数</p>
<h3 id="3-读写锁-ReadWriteLock"><a href="#3-读写锁-ReadWriteLock" class="headerlink" title="3. 读写锁 ReadWriteLock"></a>3. 读写锁 ReadWriteLock</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">readWriteLock = new ReentrantReadWriteLock()</span><br><span class="line">readLock = readWriteLock.readLock()</span><br><span class="line">writeLock = readWriteLock.writeLock()</span><br></pre></td></tr></table></figure>
<p>两把锁会根据读写关系阻塞</p>
<h3 id="4-倒计时-CountDownLatch"><a href="#4-倒计时-CountDownLatch" class="headerlink" title="4. 倒计时 CountDownLatch"></a>4. 倒计时 CountDownLatch</h3><p>用于等待有确切数量的进程完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void CountDownLatchDemo()&#123;</span><br><span class="line">    ExecutorService exec = Exectors.newFixedThreadPool(10);</span><br><span class="line">    </span><br><span class="line">    for(int i = 0; i &lt; 10; i++)</span><br><span class="line">        exec.submit(new CheckTask);</span><br><span class="line">    &#125;</span><br><span class="line">    end.await();</span><br><span class="line">    // 阻塞直到10个线程全结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CheckTask implements Runnable&#123;</span><br><span class="line">    static final CountDownLatch end = new CountDownLatch(10);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        // do some check</span><br><span class="line">        end.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-循环栅栏-CyclicBarrier"><a href="#5-循环栅栏-CyclicBarrier" class="headerlink" title="5. 循环栅栏 CyclicBarrier"></a>5. 循环栅栏 CyclicBarrier</h3><p><code>CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(...));</code><br>当执行cyclic.await()未达到N次时，一直阻塞，直到第N次后执行BarrierRun线程，且cyclic解锁<br>cyclic可以继续await()，继续触发BarrierRun</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="1-固定大小-newFixedThreadPool-空闲就执行，满了就队列等待"><a href="#1-固定大小-newFixedThreadPool-空闲就执行，满了就队列等待" class="headerlink" title="1. 固定大小 newFixedThreadPool 空闲就执行，满了就队列等待"></a>1. 固定大小 newFixedThreadPool 空闲就执行，满了就队列等待</h3><h3 id="2-单线程池-newSingleThreadPool-大小为1的-newFixedThreadPool"><a href="#2-单线程池-newSingleThreadPool-大小为1的-newFixedThreadPool" class="headerlink" title="2. 单线程池 newSingleThreadPool 大小为1的 newFixedThreadPool"></a>2. 单线程池 newSingleThreadPool 大小为1的 newFixedThreadPool</h3><h3 id="3-大小不固定-newCachedThreadPool-满了会创建新的线程"><a href="#3-大小不固定-newCachedThreadPool-满了会创建新的线程" class="headerlink" title="3. 大小不固定 newCachedThreadPool 满了会创建新的线程"></a>3. 大小不固定 newCachedThreadPool 满了会创建新的线程</h3><h3 id="4-单线程任务计划-newSingleThreadScheduledExecutor-可以延时-周期执行，大小为1"><a href="#4-单线程任务计划-newSingleThreadScheduledExecutor-可以延时-周期执行，大小为1" class="headerlink" title="4. 单线程任务计划 newSingleThreadScheduledExecutor 可以延时/周期执行，大小为1"></a>4. 单线程任务计划 newSingleThreadScheduledExecutor 可以延时/周期执行，大小为1</h3><h3 id="5-多线程任务计划-newScheduledExecutor"><a href="#5-多线程任务计划-newScheduledExecutor" class="headerlink" title="5. 多线程任务计划 newScheduledExecutor"></a>5. 多线程任务计划 newScheduledExecutor</h3><p>生成线程池方法<br><code>ExecutorService es = Executors.newFixedThreadPool(5)</code></p>
<p>执行线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">es.submit(new MyTask());</span><br><span class="line"></span><br><span class="line">public class MyTask implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run ()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK并发容器"><a href="#JDK并发容器" class="headerlink" title="JDK并发容器"></a>JDK并发容器</h2><h3 id="1-ConcurrentHashMap-高效且线程安全的HashMap"><a href="#1-ConcurrentHashMap-高效且线程安全的HashMap" class="headerlink" title="1. ConcurrentHashMap 高效且线程安全的HashMap"></a>1. ConcurrentHashMap 高效且线程安全的HashMap</h3><h3 id="2-CopyOnWriteArrayList-安全的ArrayList。在读多写少场合性能远远好于Vector"><a href="#2-CopyOnWriteArrayList-安全的ArrayList。在读多写少场合性能远远好于Vector" class="headerlink" title="2. CopyOnWriteArrayList 安全的ArrayList。在读多写少场合性能远远好于Vector"></a>2. CopyOnWriteArrayList 安全的ArrayList。在读多写少场合性能远远好于Vector</h3><h3 id="3-ConcurrentLinkedQueue-高效且安全的LinkedList"><a href="#3-ConcurrentLinkedQueue-高效且安全的LinkedList" class="headerlink" title="3. ConcurrentLinkedQueue 高效且安全的LinkedList"></a>3. ConcurrentLinkedQueue 高效且安全的LinkedList</h3><h3 id="4-BlockingQueue-阻塞队列接口，用于数据共享通道"><a href="#4-BlockingQueue-阻塞队列接口，用于数据共享通道" class="headerlink" title="4. BlockingQueue 阻塞队列接口，用于数据共享通道"></a>4. BlockingQueue 阻塞队列接口，用于数据共享通道</h3><h3 id="5-ConcurrentSkipListMap-跳表实现，用于快速查找"><a href="#5-ConcurrentSkipListMap-跳表实现，用于快速查找" class="headerlink" title="5. ConcurrentSkipListMap 跳表实现，用于快速查找"></a>5. ConcurrentSkipListMap 跳表实现，用于快速查找</h3><p>Collections工具可以将任意容器包装为线程安全的容器，例如<br><code>public static Map m = Collections.synchronizedMap(new HashMap());</code></p>
<a id="more"></a>
]]></content>
      <categories>
        <category>Java</category>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title>高并发下隐蔽的错误案例</title>
    <url>/2019/04/26/Java/%E9%AB%98%E5%B9%B6%E5%8F%91/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E9%9A%90%E8%94%BD%E7%9A%84%E9%94%99%E8%AF%AF%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="并发下的ArrayList"><a href="#并发下的ArrayList" class="headerlink" title="并发下的ArrayList"></a>并发下的ArrayList</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListMultiThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a1.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">                a1.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码，期望各添加1000 000个元素，但是遇到两种非预期结果：</p>
<ul>
<li>程序抛出异常 Exception in thread “Thread-0” java.lang.ArrayIndexOutOfBoundsException: 823</li>
<li>ArrayList大小为1000141</li>
</ul>
<p>改进方式：ArrayList换为Vector</p>
<a id="more"></a>
<h3 id="并发下的HashMap"><a href="#并发下的HashMap" class="headerlink" title="并发下的HashMap"></a>并发下的HashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapMultiThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread(<span class="number">0</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread(<span class="number">1</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="number">10000</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(Integer.toString(i), Integer.toBinaryString(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码，期望各添加10000个元素，但是遇到两种非预期结果：</p>
<ul>
<li>程序陷入死循环。在JDK 8以后规避了这个问题</li>
<li>HashMap大小为9365</li>
</ul>
<p>改进方式：HashMap换为ConcurrentHashMap</p>
<h3 id="错误的加锁"><a href="#错误的加锁" class="headerlink" title="错误的加锁"></a>错误的加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadLockOnIntegerTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> BadLockOnIntegerTest instance = <span class="keyword">new</span> BadLockOnIntegerTest();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BadLockOnIntegerTest());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BadLockOnIntegerTest());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码，期望输出2000，但是返回1415，原因是Integer属于不变对象。<code>i++</code> 在真实执行时变成了<code>i=Integer.valueOf(i.intValue()+1);</code></p>
<p>导致每次加锁加到了不同的对象实例上。</p>
<p>改进方式：<code>synchronized(i)</code>修改为<code>synchronized(instance)</code></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title>什么时候用volatile？</title>
    <url>/2020/07/13/Java/%E9%AB%98%E5%B9%B6%E5%8F%91/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8volatile%EF%BC%9F/</url>
    <content><![CDATA[<p>Java线程之间变量可见性不是即时同步的，有缓存。添加volatile可以确保其他线程能看到最新的值</p>
<a id="more"></a>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5>]]></content>
      <categories>
        <category>Java</category>
        <category>高并发</category>
      </categories>
  </entry>
</search>
